Changed from version 1.14 --> 1.20

changes:
- support for boundary segment indices 
- support for boundary projection for curved boundaries

bug fixes:
- MPI cleanup, only the C interface of MPI is used (and linked)
- bug fix for vertex and edge communication 
- bug fix for ParMETIS function declaration 


Index: serial/parallel.h
===================================================================
--- serial/parallel.h	(revision 1064)
+++ serial/parallel.h	(revision 1173)
@@ -17,18 +17,22 @@
         BufferType * _buff; 
 
         CommunicationBuffer () : _buff(0) {}
-        ~CommunicationBuffer () { if(_buff) delete _buff; }
+        ~CommunicationBuffer () 
+        { 
+          if(_buff) delete _buff; 
+          _buff = 0;  
+        }
       public:   
-        void reserveBuffer (int size)
+        void reserveBuffer (const size_t size)
         {
           if(_buff) 
           {
-            if(size > (int) _buff->size())
-              _buff->resize(size);
+            // adjust size 
+            if( size > _buff->size() ) _buff->resize( size );
           }
           else 
           {
-            _buff = new BufferType(size); 
+            _buff = new BufferType( size ); 
           }
         }
         BufferType & commBuffer () { assert(_buff); return *_buff; }
@@ -37,7 +41,8 @@
     
     class AccessPllException {} ;
   
-    class VertexIF : public CommunicationBuffer {
+    class VertexIF : public CommunicationBuffer 
+    {
       public :
         virtual ~VertexIF () {}
         typedef class Key1SLZ identifier_t ;
@@ -45,13 +50,14 @@
         inline virtual const VertexPllXIF_t & accessPllX () const throw (AccessPllException) ;
         inline virtual void detachPllXFromMacro () throw (AccessPllException) ;
     } ;
-    class EdgeIF : public CommunicationBuffer {
+    class EdgeIF : public CommunicationBuffer 
+    {
       public :
         virtual ~EdgeIF () {}
         typedef class Key2SLZ identifier_t ;
         inline virtual EdgePllXIF_t & accessPllX () throw (AccessPllException) ;
         inline virtual const EdgePllXIF_t & accessPllX () const throw (AccessPllException) ;
-  inline virtual void detachPllXFromMacro () throw (AccessPllException) ;
+        inline virtual void detachPllXFromMacro () throw (AccessPllException) ;
     } ;
     class FaceIF {
       public :
@@ -59,7 +65,7 @@
         typedef class Key3SLZ identifier_t ;
         inline virtual FacePllXIF_t & accessPllX () throw (AccessPllException) ;
         inline virtual const FacePllXIF_t & accessPllX () const throw (AccessPllException) ;
-  inline virtual void detachPllXFromMacro () throw (AccessPllException) ;
+        inline virtual void detachPllXFromMacro () throw (AccessPllException) ;
     } ;
     class ElementIF {
       public :
Index: serial/walk.h
===================================================================
--- serial/walk.h	(revision 1064)
+++ serial/walk.h	(revision 1173)
@@ -648,8 +648,11 @@
 
 template < class A > VectorAlign < A > :: ~VectorAlign () {
   typedef typename vector < pointer_t > :: iterator iterator_t ; 
-  iterator_t pend = _it.end (); 
-  for (iterator_t p = _it.begin (); p != pend ; delete (*p ++)) ;
+  const iterator_t pend = _it.end (); 
+  for (iterator_t p = _it.begin (); p != pend ; ++p ) 
+  {
+    delete *p;
+  }
   return ;
 }
 
Index: serial/gitter_sti.h
===================================================================
--- serial/gitter_sti.h	(revision 1064)
+++ serial/gitter_sti.h	(revision 1173)
@@ -12,12 +12,13 @@
 #include "parallel.h"
 #include "xdrclass.h"
 
-class ProjectVertex {
-public:
-  virtual ~ProjectVertex () {}
-  virtual int operator()(const double (&p)[3],double (&ret)[3]) const = 0;
-};
+// interface class for projecting vertices for boundary adjustment 
+typedef VertexProjection<3> ProjectVertex;
+// see ../projectvertex.h 
 
+// pair of projection and bnd segment index 
+typedef pair<const ProjectVertex* , const int > ProjectVertexPair;
+
 // forward declaration, see ghost_info.h 
 class MacroGhostInfoHexa;
 class MacroGhostInfoTetra;
@@ -370,7 +371,7 @@
     virtual int level () const = 0 ;
 
     // Methode um einen Vertex zu verschieben; f"ur die Randanpassung
-    virtual void project(const ProjectVertex &pv) = 0; 
+    virtual void project(const ProjectVertexPair &pv) = 0; 
   
     // Extrainteger, damit die Element zu Vertex Zuordnug klappt,
     // wenn die Daten zur Visualisierung mit GRAPE rausgeschrieben
@@ -409,7 +410,7 @@
     //virtual void backup (XDRstream_out &) const {};
     //virtual void restore (XDRstream_in &) {};
     // Methode um einen Vertex zu verschieben; f"ur die Randanpassung
-    virtual void projectInnerVertex(const ProjectVertex &pv) = 0; 
+    virtual void projectInnerVertex(const ProjectVertexPair &pv) = 0; 
 
     // backup and restore index of vertices, should be overloaded in
     // derived classes, because some need to go down the hierarchiy
@@ -442,7 +443,7 @@
     virtual void restore (ObjectStream &) = 0 ;
         
     // Methode um einen Vertex zu verschieben; f"ur die Randanpassung
-    virtual void projectVertex(const ProjectVertex &pv) = 0;
+    virtual void projectVertex(const ProjectVertexPair &pv) = 0;
 
     // returns true if element conected to face is leaf 
     virtual bool isInteriorLeaf() const = 0;
@@ -633,6 +634,9 @@
     }
     
     virtual bnd_t bndtype () const = 0 ;
+
+    // return index of boundary segment 
+    virtual int   segmentIndex () const = 0 ;
         
     // for dune 
     virtual hbndseg * up () = 0 ;
@@ -654,7 +658,7 @@
     // the int is -1 by default, or the internal ghostFace number (
     // getGhostFaceNumber) when ghost is non-zero 
     virtual const pair < helement * ,int> & getGhost () const = 0; 
-    
+
   protected:
     // if ghost element exists, then ghost is splitted, when bnd is splitted 
     // info will be filled with the new ghost cells and local face to the
@@ -862,6 +866,9 @@
       virtual bool isboundary() const = 0;    
       virtual int nbLevel() const = 0;
       virtual int nbLeaf() const = 0;
+
+      // returns true if a vertex projection is set 
+      virtual bool hasVertexProjection () const = 0;
     } ;
 
     class hasFace4 : public virtual stiExtender_t :: ElementIF {
@@ -881,6 +888,9 @@
       virtual bool isboundary() const = 0;
       virtual int nbLevel() const  = 0;
       virtual int nbLeaf() const = 0; 
+
+      // returns true if a vertex projection is set 
+      virtual bool hasVertexProjection () const = 0;
     } ;
 
     // hasFace_t is hasFace3 and hasFace4 
@@ -907,6 +917,9 @@
 
       // as we have not a real element or boundary here, return false 
       bool isRealObject () const { return false; }
+
+      // return false for vertex projection  
+      inline bool hasVertexProjection() const { return false; }
     private:
       hasFaceEmpty () {}
       hasFaceEmpty (const hasFaceEmpty & );
@@ -932,7 +945,7 @@
       // return level of vertex 
       inline int level () const ;
       // Methode um einen Vertex zu verschieben; f"ur die Randanpassung
-      virtual inline void project(const ProjectVertex &pv) ; 
+      virtual inline void project(const ProjectVertexPair &pv) ; 
             
       // overload backupIndex and restoreIndex here
       inline void backupIndex  (ostream & os ) const;
@@ -1169,6 +1182,9 @@
       virtual int nbLevel() const {return level();}
       // returns leaf 
       virtual int nbLeaf() const {return leaf();}
+
+      // returns false because only bnd segments have projections 
+      virtual bool hasVertexProjection () const { return false; }
     public :
       virtual myrule_t getrule () const = 0 ;
       
@@ -1240,6 +1256,9 @@
       virtual int nbLevel() const {return level();}
       // just returns leaf 
       virtual int nbLeaf() const {return leaf();}
+
+      // return false for vertex projection  
+      virtual bool hasVertexProjection() const { return false; }
     private :
       myhface3_t * f [2] ;
       signed char s [2] ;
@@ -1292,6 +1311,9 @@
       virtual int nbLevel() const {return level();}
       // just returns leaf 
       virtual int nbLeaf() const {return leaf();}
+
+      // returns false because only bnd segments have projections 
+      virtual bool hasVertexProjection () const { return false; }
     private :
       myhface4_t * f [2] ;
       signed char s [2] ;
@@ -1357,6 +1379,9 @@
       virtual int nbLevel() const {return level();}
       // just returns leaf 
       virtual int nbLeaf() const {return leaf();}
+
+      // returns false because only bnd segments have projections 
+      virtual bool hasVertexProjection () const { return false; }
     public :
       virtual myrule_t getrule () const = 0 ;
       virtual myrule_t requestrule () const = 0;
@@ -1403,6 +1428,7 @@
       inline int postRefinement () ;
       inline int preCoarsening () ;
       inline bool lockedAgainstCoarsening () const { return false ; }
+      inline bool hasVertexProjection() const { return (_projection != 0); }
     public :
       inline virtual ~hbndseg3 () ;
       inline myrule_t getrule () const ;
@@ -1446,11 +1472,12 @@
           face.myvertex(i)->removeleaf();
         }
       }
+    protected :
+      ProjectVertex* _projection;
+
     private :
       myhface3_t * _face ;
       int _twist ;
-    protected :
-      ProjectVertex *projection;
     public:  
     } hbndseg3_GEO ;
   
@@ -1469,6 +1496,7 @@
       inline int postRefinement () ;
       inline int preCoarsening () ;
       inline bool lockedAgainstCoarsening () const { return false ; }
+      inline bool hasVertexProjection() const { return (_projection != 0); }
     public :
       inline virtual ~hbndseg4 () ;
       inline myrule_t getrule () const ;
@@ -1509,11 +1537,11 @@
           face.myvertex(i)->removeleaf();
         }
       }
+    protected :
+      ProjectVertex* _projection;
     private :
       myhface4_t * _face ;
       int _twist ;
-    protected :
-      ProjectVertex *projection;
 
     public:   
     } hbndseg4_GEO ;
@@ -1578,7 +1606,7 @@
       // generates macro image from macro file 
       void generateRawHexaImage (istream &, ostream &) ;
       
-      virtual void macrogridBuilder (istream &) ;
+      virtual void macrogridBuilder (istream &, ProjectVertex* ) ;
       virtual VertexGeo     * insert_vertex (double, double, double, int) = 0 ;
       virtual VertexGeo     * insert_ghostvx(double, double, double, int) = 0 ;
       virtual hedge1_GEO    * insert_hedge1 (VertexGeo *, VertexGeo *) = 0 ;
@@ -1591,16 +1619,16 @@
       
       virtual hexa_GEO      * insert_hexa (hface4_GEO *(&)[6], int (&)[6]) = 0 ;
       
-      virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, hbndseg_STI :: bnd_t) = 0 ;
+      virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, ProjectVertex*, hbndseg_STI :: bnd_t) = 0 ;
 
       // insert ghost element 
-      virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, hbndseg_STI:: bnd_t, 
+      virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, ProjectVertex*, hbndseg_STI:: bnd_t, 
                                             MacroGhostInfoTetra* ) = 0 ;
       
-      virtual hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, hbndseg_STI :: bnd_t) = 0 ;
+      virtual hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, ProjectVertex*, hbndseg_STI :: bnd_t) = 0 ;
 
       // method to insert internal boundary with ghost 
-      virtual hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, hbndseg_STI :: bnd_t, 
+      virtual hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, ProjectVertex*, hbndseg_STI :: bnd_t, 
                                             MacroGhostInfoHexa* ) = 0 ;
 
       IteratorSTI < vertex_STI > * iterator (const vertex_STI *) const ;
@@ -1647,6 +1675,9 @@
       // return reference to indexManager 
       virtual IndexManagerType& indexManager(int codim);
 
+      // return number of macro boundary segments 
+      virtual size_t numMacroBndSegments() const;
+
       // compress all index manager 
       virtual void compressIndexManagers();
       
@@ -1707,6 +1738,9 @@
   virtual int preCoarsening ( hbndseg_STI & ) { return 0; }
   virtual int postRefinement( hbndseg_STI & ) { return 0; }
 
+  // return pointer to vertex projection 
+  virtual ProjectVertex* vertexProjection() const = 0; 
+
   virtual void fullIntegrityCheck () ;
   virtual void printsize () ;
   virtual bool adapt () ;
@@ -1729,6 +1763,8 @@
   virtual void backup (XDRstream_out &) ;
   virtual void restore (XDRstream_in &) ;
 
+  virtual size_t numMacroBndSegments() const = 0;
+
   // return index manager of macro grid 
   virtual IndexManagerType & indexManager (int codim) = 0;
 
@@ -2191,11 +2227,18 @@
   return _lvl ;
 }
 
-inline void Gitter :: Geometric :: VertexGeo :: project(const ProjectVertex &pv) {
-  double p[3] = {_c[0],_c[1],_c[2]};
-  if (!pv(p,_c)) {
-    cerr << "FEHLER in Gitter :: Geometric :: VertexGeo :: project(const ProjectVertex &pv) " 
-         << "keine Randanpassung m\"oglich!" << endl;
+inline void Gitter :: Geometric :: VertexGeo :: project(const ProjectVertexPair &pv) 
+{
+  // copy current coordinates  
+  const double p[3] = {_c[0],_c[1],_c[2]};
+  // call projection operator 
+  assert( pv.first );
+  const int ok = (*pv.first)( p, pv.second, _c );
+
+  if ( ! ok ) 
+  {
+    cerr << "ERROR in Gitter :: Geometric :: VertexGeo :: project(const ProjectVertexPair &pv) " 
+         << "no boundary projection possible!" << endl;
     _c[0] = p[0]; _c[1] = p[1]; _c[2] = p[2];
   }
 }
@@ -3188,7 +3231,9 @@
 // #     #  #####   #    #  #####    ####   ######   ####   #####
 
 inline Gitter :: Geometric :: hbndseg3 :: 
-hbndseg3 (myhface3_t * a, int b, ProjectVertex *ppv) : _face (a), _twist (b), projection(ppv) {
+hbndseg3 (myhface3_t * a, int b, ProjectVertex *ppv) 
+  : _projection(ppv), _face (a), _twist (b)
+{
   _face->attachElement (pair < hasFace3 *, int > (InternalHasFace3 ()(this),0), _twist) ;
   return ;
 }
@@ -3198,14 +3243,18 @@
   return ;
 }
 
-inline int Gitter :: Geometric :: hbndseg3 :: postRefinement () {
-  if (projection) {
-    myhface3(0)->projectVertex(*projection);
+inline int Gitter :: Geometric :: hbndseg3 :: postRefinement () 
+{
+  if (_projection) 
+  {
+    ProjectVertexPair pv( _projection, segmentIndex() );
+    myhface3(0)->projectVertex( pv );
   }
   return 0 ;
 }
 
-inline int Gitter :: Geometric :: hbndseg3 :: preCoarsening () {
+inline int Gitter :: Geometric :: hbndseg3 :: preCoarsening () 
+{
   return 0 ;
 }
 
@@ -3245,7 +3294,9 @@
 // #     #  #    #  #   ##  #    #  #    #  #       #    #      #
 // #     #  #####   #    #  #####    ####   ######   ####       #
 
-inline Gitter :: Geometric :: hbndseg4 :: hbndseg4 (myhface4_t * a, int b, ProjectVertex *ppv) : _face (a), _twist (b), projection(ppv) {
+inline Gitter :: Geometric :: hbndseg4 :: hbndseg4 (myhface4_t * a, int b, ProjectVertex *ppv) 
+  :  _projection(ppv), _face (a), _twist (b) 
+{
   _face->attachElement (pair < hasFace4 *, int > (InternalHasFace4 ()(this),0), _twist) ;
   return ;
 }
@@ -3255,18 +3306,23 @@
   return ;
 }
 
-inline int Gitter :: Geometric :: hbndseg4 :: postRefinement () {
-  if (projection) {
-    myhface4(0)->projectVertex(*projection);
+inline int Gitter :: Geometric :: hbndseg4 :: postRefinement () 
+{
+  if (_projection) 
+  {
+    ProjectVertexPair pv( _projection, segmentIndex() );
+    myhface4(0)->projectVertex( pv );
   }
   return 0 ;
 }
 
-inline int Gitter :: Geometric :: hbndseg4 :: preCoarsening () {
+inline int Gitter :: Geometric :: hbndseg4 :: preCoarsening () 
+{
   return 0 ;
 }
 
-inline int Gitter :: Geometric :: hbndseg4 :: twist (int i) const {
+inline int Gitter :: Geometric :: hbndseg4 :: twist (int i) const 
+{
   assert (i == 0) ;
   return _twist ;
 }
Index: serial/gitter_tetra_top.h
===================================================================
--- serial/gitter_tetra_top.h	(revision 1064)
+++ serial/gitter_tetra_top.h	(revision 1173)
@@ -95,6 +95,7 @@
 
     int _lvl ;
     const bnd_t _bt; // type of boundary 
+    int _segmentIndex; // segment index of macro face 
 
     void split_e01 () ;
     void split_e12 () ;
@@ -105,23 +106,19 @@
   public:
     // constructor for serial macro boundary elements  
     inline Hbnd3Top (int,myhface3_t *,int,ProjectVertex *,
-                     innerbndseg_t * up,const bnd_t b, 
-                     IndexManagerType & im , Gitter * ) ;
+                     const bnd_t b, IndexManagerType & im ) ;
     
     // constructor for children 
     inline Hbnd3Top (int,myhface3_t *,int, ProjectVertex *, 
                     innerbndseg_t * up, const bnd_t b, 
                     IndexManagerType & im, typename Gitter::helement_STI * gh, int gFace ) ;
-    // constructor for macro elements 
-    inline Hbnd3Top (int,myhface3_t *,int,ProjectVertex *, 
-                    innerbndseg_t * up, const bnd_t b, 
-                    IndexManagerType & im, Gitter * grd, 
-                    typename Gitter::helement_STI * gh, int ) ;
+
     inline virtual ~Hbnd3Top () ;
     bool refineBalance (balrule_t,int) ;
     bool bndNotifyCoarsen () ;
     void restoreFollowFace () ;
     inline int level () const ;
+    inline int segmentIndex () const ;
     inline innerbndseg_t * next () ;
     inline innerbndseg_t * down () ;
     inline const innerbndseg_t * next () const ;
@@ -164,6 +161,7 @@
   private :
     inline IndexManagerType & getFaceIndexManager ();
     inline IndexManagerType & getEdgeIndexManager ();
+    double calculateChildVolume(const double) const;
     
     void split_e01 () ;
     void split_e12 () ;
@@ -171,7 +169,7 @@
     void split_e23 () ;
     void split_e30 () ;
     void split_e31 () ;
-    void split_iso8 () ;
+    void splitISO8 () ;
   protected :
     myhedge1_t * subedge1 (int,int) ;
     const myhedge1_t * subedge1 (int,int) const ;
@@ -723,46 +721,39 @@
 
 // serial macro bnd constructor 
 template < class A > inline Hbnd3Top < A > :: 
-Hbnd3Top (int l, myhface3_t * f, int i, ProjectVertex *ppv, 
-          innerbndseg_t * up, const bnd_t bt, IndexManagerType & im , Gitter * grd ) : 
-  A (f, i, ppv , grd ), _bbb (0), _dwn (0), _up (0) , 
+Hbnd3Top (int l, myhface3_t * f, int i, 
+          ProjectVertex* ppv, 
+          const bnd_t bt, 
+          IndexManagerType & im ) :
+  A (f, i, ppv ), _bbb (0), _dwn (0), _up (0) , 
   _indexManager(im) ,
   _lvl (l), _bt (bt) 
 {
   this->setIndex( _indexManager.getIndex() );
+  // for macro bnd faces store current index as segment index 
+  _segmentIndex = this->getIndex();
   setBoundaryId( _bt ); 
   return ;
 }
 
 template < class A > inline Hbnd3Top < A > :: 
-Hbnd3Top (int l, myhface3_t * f, int i, ProjectVertex *ppv, 
-          innerbndseg_t * up, bnd_t bt, IndexManagerType & im, 
+Hbnd3Top (int l, myhface3_t * f, 
+          int i, ProjectVertex *ppv, 
+          innerbndseg_t * up, bnd_t bt, 
+          IndexManagerType & im, 
           Gitter::helement_STI * gh, int gFace ) : 
-  A (f, i, ppv , up->_myGrid ), _bbb (0), _dwn (0), _up (up) , 
+  A (f, i, ppv ), _bbb (0), _dwn (0), _up (up) , 
   _indexManager(im) ,
-  _lvl (l), _bt (bt)  
+  _lvl (l), 
+  _bt (bt) 
 {
   typedef Gitter :: ghostpair_STI ghostpair_STI;
   this->setGhost ( ghostpair_STI (gh , gFace) );
   this->setIndex( _indexManager.getIndex() );
-  
-  setBoundaryId( _bt ); 
-  return ;
-}
 
-template < class A > inline Hbnd3Top < A > :: 
-Hbnd3Top (int l, myhface3_t * f, int i, ProjectVertex *ppv, 
-          innerbndseg_t * up, bnd_t bt, IndexManagerType & im, 
-          Gitter * grd , Gitter::helement_STI * gh, int gFace) : 
-  A (f, i, ppv , grd ), _bbb (0), _dwn (0), _up (up) , 
-  _indexManager(im) ,
-  _lvl (l), _bt (bt) 
-{
-  typedef Gitter :: ghostpair_STI ghostpair_STI;
-  this->setGhost ( ghostpair_STI (gh , gFace) );
-  this->setIndex( _indexManager.getIndex() );
-
-  // set boundary tpye to bnd id of all items 
+  // get segment index from father if existent 
+  _segmentIndex = (_up) ? _up->_segmentIndex : this->getIndex() ;
+ 
   setBoundaryId( _bt ); 
   return ;
 }
@@ -789,6 +780,10 @@
   }
 }
 
+template < class A > inline int Hbnd3Top < A > :: segmentIndex () const {
+  return _segmentIndex;
+}
+
 template < class A > inline int Hbnd3Top < A > :: level () const {
   return _lvl ;
 }
@@ -826,8 +821,8 @@
 template < class A > inline void Hbnd3Top < A > :: split_e01 () {
   int l = 1 + level () ;
   int gFace = this->getGhost().second ;
-  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->projection, this , _bt, _indexManager, 0 , gFace) ;
-  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->projection, this , _bt, _indexManager, 0 , gFace) ;
+  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->_projection, this , _bt, _indexManager, 0 , gFace) ;
+  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->_projection, this , _bt, _indexManager, 0 , gFace) ;
   assert (b0 && b1) ;
   b0->append(b1) ;
   _dwn = b0 ;
@@ -837,8 +832,8 @@
 template < class A > inline void Hbnd3Top < A > :: split_e12 () {
   int l = 1 + level () ;
   int gFace = this->getGhost().second ;
-  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->projection, this , _bt, _indexManager, 0 , gFace) ;
-  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->projection, this , _bt, _indexManager, 0 , gFace) ;
+  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->_projection, this , _bt, _indexManager, 0 , gFace) ;
+  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->_projection, this , _bt, _indexManager, 0 , gFace) ;
   assert (b0 && b1) ;
   b0->append(b1) ;
   _dwn = b0 ;
@@ -848,8 +843,8 @@
 template < class A > inline void Hbnd3Top < A > :: split_e20 () {
   int l = 1 + level () ;
   int gFace = this->getGhost().second ;
-  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->projection, this , _bt, _indexManager, 0, gFace) ;
-  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->projection, this , _bt, _indexManager, 0, gFace) ;
+  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->_projection, this , _bt, _indexManager, 0, gFace) ;
+  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->_projection, this , _bt, _indexManager, 0, gFace) ;
   assert (b0 && b1) ;
   b0->append(b1) ;
   _dwn = b0 ;
@@ -865,10 +860,10 @@
   // ghostInfo is filled by splitGhost, see gitter_tetra_top_pll.h
   this->splitGhost( ghostInfo );
 
-  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->projection, this , _bt, _indexManager, ghostInfo.child(0), ghostInfo.face(0)) ;
-  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->projection, this , _bt, _indexManager, ghostInfo.child(1), ghostInfo.face(1)) ;
-  innerbndseg_t * b2 = new innerbndseg_t (l, this->subface3 (0,2), this->twist (0), this->projection, this , _bt, _indexManager, ghostInfo.child(2), ghostInfo.face(2)) ;
-  innerbndseg_t * b3 = new innerbndseg_t (l, this->subface3 (0,3), this->twist (0), this->projection, this , _bt, _indexManager, ghostInfo.child(3), ghostInfo.face(3)) ;
+  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface3 (0,0), this->twist (0), this->_projection, this , _bt, _indexManager, ghostInfo.child(0), ghostInfo.face(0)) ;
+  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface3 (0,1), this->twist (0), this->_projection, this , _bt, _indexManager, ghostInfo.child(1), ghostInfo.face(1)) ;
+  innerbndseg_t * b2 = new innerbndseg_t (l, this->subface3 (0,2), this->twist (0), this->_projection, this , _bt, _indexManager, ghostInfo.child(2), ghostInfo.face(2)) ;
+  innerbndseg_t * b3 = new innerbndseg_t (l, this->subface3 (0,3), this->twist (0), this->_projection, this , _bt, _indexManager, ghostInfo.child(3), ghostInfo.face(3)) ;
   assert (b0 && b1 && b2 && b3) ;
   b0->append(b1) ;
   b1->append(b2) ;
@@ -1080,7 +1075,13 @@
              myhface3_t * f3, int t3, innertetra_t *up, int nChild, double vol) 
   : A (f0, t0, f1, t1, f2, t2, f3, t3, up->_myGrid), _dwn (0), _bbb (0), _up(up), _fc (0), _ed (0)
   , _indexManager(up->_indexManager) 
-  , _volume(vol) 
+  , _volume( (vol < 0.0) ?  
+            quadraturTetra3D < VolumeCalc > (
+                LinearMapping ( this->myvertex(0)->Point(), 
+                                this->myvertex(1)->Point(),
+                                this->myvertex(2)->Point(), 
+                                this->myvertex(3)->Point())).integrate1 (0.0) 
+            : vol )
   , _lvl (l) 
   , _rule (myrule_t :: nosplit)
   , _nChild(nChild) 
@@ -1114,9 +1115,9 @@
   : A (f0, t0, f1, t1, f2, t2, f3, t3, mygrid),
     _dwn (0), _bbb (0), _up(0), _fc (0),_ed (0)
   , _indexManager(im)
-  , _volume(quadraturTetra3D < VolumeCalc > 
+  , _volume( quadraturTetra3D < VolumeCalc > 
     (LinearMapping ( this->myvertex(0)->Point(), this->myvertex(1)->Point(),
-                     this->myvertex(2)->Point(), this->myvertex(3)->Point())).integrate1 (0.0))
+                     this->myvertex(2)->Point(), this->myvertex(3)->Point())).integrate1 (0.0) )
   , _lvl (l) 
   , _rule (myrule_t :: nosplit) 
   , _nChild(0)  // we are macro ==> nChild 0 
@@ -1141,6 +1142,13 @@
   return ;
 }
 
+template < class A > inline double TetraTop < A > :: calculateChildVolume (const double childVolume) const 
+{
+  // if vertex projection is available on a neighbor 
+  // volume has to be recalculated 
+  return ( this->_myGrid->vertexProjection() ) ? -1.0 : childVolume; 
+}
+
 template < class A > inline int TetraTop < A > :: level () const {
   return _lvl ;
 }
@@ -1295,7 +1303,9 @@
   innerface_t * f0 = new innerface_t (l, this->subedge1 (3, 3), 1, this->subedge1 (0, 3), 0, this->subedge1 (2, 2), 0, getFaceIndexManager() ) ;
   assert(f0) ;
 
-  double childVolume = 0.5 * _volume;
+  // we divide by 2 means we divide the volume by 2
+  const double childVolume = calculateChildVolume( 0.5 * _volume );
+  
   innertetra_t * h0 = new innertetra_t (l, this->subface3(0, 0), this->twist (0), f0, 0, this->myhface3(2), this->twist (2), this->subface3(3, 0), this->twist (3), this, 0, childVolume) ;
   innertetra_t * h1 = new innertetra_t (l, this->subface3(0, 1), this->twist (0), this->myhface3(1), this->twist (1), f0, 1, this->subface3(3, 1), this->twist (3), this, 1, childVolume) ;
   assert(h0 && h1) ;
@@ -1311,7 +1321,10 @@
   
   innerface_t * f0 = new innerface_t (l, this->subedge1 (3, 3), 1, this->subedge1 (0, 3), 0, this->subedge1 (2, 2), 0, getFaceIndexManager() ) ;
   assert(f0 ) ;
-  double childVolume = 0.5 * _volume;
+
+  // we divide by 2 means we divide the volume by 2
+  const double childVolume = calculateChildVolume( 0.5 * _volume );
+  
   innertetra_t * h0 = new innertetra_t (l, this->subface3(0, 0), this->twist (0), f0, 0, this->myhface3(2), this->twist (2), this->subface3(3, 0), this->twist (3), this, 0, childVolume) ;
   innertetra_t * h1 = new innertetra_t (l, this->subface3(0, 1), this->twist (0), this->myhface3(1), this->twist (1), f0, 1, this->subface3(3, 1), this->twist (3), this, 1, childVolume) ;
   assert(h0 && h1) ;
@@ -1327,7 +1340,10 @@
   
   innerface_t * f0 = new innerface_t (l, this->subedge1 (3, 3), 1, this->subedge1 (0, 3), 0, this->subedge1 (2, 2), 0, getFaceIndexManager() ) ;
   assert(f0) ;
-  double childVolume = 0.5 * _volume;
+
+  // we divide by 2 means we divide the volume by 2
+  const double childVolume = calculateChildVolume( 0.5 * _volume );
+  
   innertetra_t * h0 = new innertetra_t (l, this->subface3(0, 0), this->twist (0), f0, 0, this->myhface3(2), this->twist (2), this->subface3(3, 0), this->twist (3), this, 0, childVolume) ;
   innertetra_t * h1 = new innertetra_t (l, this->subface3(0, 1), this->twist (0), this->myhface3(1), this->twist (1), f0, 1, this->subface3(3, 1), this->twist (3), this, 1, childVolume) ;
   assert(h0 && h1) ;
@@ -1343,7 +1359,10 @@
   
   innerface_t * f0 = new innerface_t (l, this->subedge1 (3, 3), 1, this->subedge1 (0, 3), 0, this->subedge1 (2, 2), 0, getFaceIndexManager() ) ;
   assert(f0) ;
-  double childVolume = 0.5 * _volume;
+
+  // we divide by 2 means we divide the volume by 2
+  const double childVolume = calculateChildVolume( 0.5 * _volume );
+  
   innertetra_t * h0 = new innertetra_t (l, this->subface3(0, 0), this->twist (0), f0, 0, this->myhface3(2), this->twist (2), this->subface3(3, 0), this->twist (3), this, 0, childVolume) ;
   innertetra_t * h1 = new innertetra_t (l, this->subface3(0, 1), this->twist (0), this->myhface3(1), this->twist (1), f0, 1, this->subface3(3, 1), this->twist (3), this, 1, childVolume) ;
   assert(h0 && h1) ;
@@ -1376,7 +1395,10 @@
   
   innerface_t * f0 = new innerface_t (l, this->subedge1 (3, 3), 1, this->subedge1 (0, 3), 0, this->subedge1 (2, 2), 0, getFaceIndexManager()) ;
   assert(f0) ;
-  double childVolume = 0.5 * _volume;
+
+  // we divide by 2 means we divide the volume by 2
+  const double childVolume = calculateChildVolume( 0.5 * _volume );
+  
   innertetra_t * h0 = new innertetra_t (l, this->subface3(0, 0), this->twist (0), f0, 0, this->myhface3(2), this->twist (2), this->subface3(3, 0), this->twist (3), this, 0, childVolume) ;
   innertetra_t * h1 = new innertetra_t (l, this->subface3(0, 1), this->twist (0), this->myhface3(1), this->twist (1), f0, 1, this->subface3(3, 1), this->twist (3), this, 1, childVolume) ;
   assert(h0 && h1) ;
@@ -1388,7 +1410,7 @@
 }
 
 template < class A > inline void TetraTop < A > :: 
-split_iso8 () 
+splitISO8 () 
 {
   typedef typename A :: myvertex_t  myvertex_t;
   typedef typename A :: inneredge_t inneredge_t;
@@ -1418,7 +1440,8 @@
   f6->append(f7) ;
 
   // we divide by 8 means we divide the volume by 8
-  double childVolume = 0.125 * _volume; 
+  const double childVolume = calculateChildVolume( 0.125 * _volume );
+  
   // pointer `this' is the pointer to the father element 
   innertetra_t * h0 = new innertetra_t (l, f0, -1, this->subface3(1, 0), this->twist(1), this->subface3(2, 0), this->twist(2), this->subface3(3, 0), this->twist(3), this, 0 , childVolume) ;
   innertetra_t * h1 = new innertetra_t (l, this->subface3(0, 0), this->twist(0), f1, -3, this->subface3(2, 2), this->twist(2), this->subface3(3, 1), this->twist(3), this, 1 , childVolume) ;
@@ -1464,7 +1487,23 @@
 {
   assert (getrule () == myrule_t :: nosplit) ;
   typedef typename myhface3_t :: myrule_t myhface3rule_t;
-  switch(r) {
+
+  switch(r) 
+  {
+    case myrule_t :: iso8 :
+        
+      // Das refineImmediate (..) auf allen Fl"achen wird vom tetra :: refine (..)
+      // zwar nicht ben"otigt, da schliesslich alle Fl"achen sauber sind, wenn
+      // "uberall hface3 :: refine (..) true geliefert hat, wohl aber z.B. von
+      // restore () oder abgeleiteten Funktionen die eine direkte Verfeinerung
+      // erzwingen m"ussen und d"urfen.
+        
+      {
+        for (int i = 0 ; i < 4 ; i ++)
+          this->myhface3 (i)->refineImmediate (myhface3rule_t (myhface3_t :: myrule_t :: iso4).rotate (this->twist (i))) ; 
+      }
+      splitISO8 () ;
+      break ;
     case myrule_t :: e01 :
       this->myhface3 (2)->refineImmediate (myhface3rule_t (myhface3_t :: myrule_t :: e01).rotate (this->twist (2))) ;
       this->myhface3 (3)->refineImmediate (myhface3rule_t (myhface3_t :: myrule_t :: e01).rotate (this->twist (3))) ;
@@ -1495,20 +1534,6 @@
       this->myhface3 (2)->refineImmediate (myhface3rule_t (myhface3_t :: myrule_t :: e01).rotate (this->twist (2))) ;
       split_e31 () ;
       break ;
-    case myrule_t :: iso8 :
-    
-  // Das refineImmediate (..) auf allen Fl"achen wird vom tetra :: refine (..)
-  // zwar nicht ben"otigt, da schliesslich alle Fl"achen sauber sind, wenn
-  // "uberall hface3 :: refine (..) true geliefert hat, wohl aber z.B. von
-  // restore () oder abgeleiteten Funktionen die eine direkte Verfeinerung
-  // erzwingen m"ussen und d"urfen.
-    
-      {
-        for (int i = 0 ; i < 4 ; i ++)
-          this->myhface3 (i)->refineImmediate (myhface3rule_t (myhface3_t :: myrule_t :: iso4).rotate (this->twist (i))) ; 
-      }
-      split_iso8 () ;
-      break ;
     default :
       cerr << "**FEHLER (FATAL) beim unbedingten Verfeinern mit unbekannter Regel: " ;
       cerr << "[" << r << "]. In " << __FILE__ << __LINE__ << endl ;
@@ -2095,7 +2120,7 @@
     }
   }
   //soweit von Hbnd
-	
+  
   int l = 1 + this->level () ;
   innerperiodic3_t * p0 = new innerperiodic3_t (l, this->subface3 (0,0), this->twist (0), this->subface3 (1,0), this->twist (1), this , 0) ;
   innerperiodic3_t * p1 = new innerperiodic3_t (l, this->subface3 (0,1), this->twist (0), this->subface3 (1,2), this->twist (1), this , 1) ;
Index: serial/gitter_impl.h
===================================================================
--- serial/gitter_impl.h	(revision 1064)
+++ serial/gitter_impl.h	(revision 1173)
@@ -58,7 +58,7 @@
 #endif
         {
           protected :
-           inline Hbnd3Default (myhface3_t *, int, ProjectVertex * , Gitter * ) ;
+           inline Hbnd3Default (myhface3_t *, int, ProjectVertex * ) ;
            virtual ~Hbnd3Default () {}
           public :
             typedef hbndseg3_GEO :: bnd_t bnd_t;
@@ -74,13 +74,8 @@
               return p;
             }
 
-            inline int preCoarsening  () ;
-            inline int postRefinement () ;
-
             // default implementation returns 0
             virtual const MacroGhostInfo* buildGhostCell(ObjectStream&, int) { return 0; }
-          protected:
-            Gitter * _myGrid; 
         };
         typedef Hbnd3Top < Hbnd3Default > hbndseg3_IMPL ;
 
@@ -104,7 +99,7 @@
 #endif
         {
           protected :
-            inline Hbnd4Default (myhface4_t *, int, ProjectVertex *, Gitter *) ;
+            inline Hbnd4Default (myhface4_t *, int, ProjectVertex * ) ;
             virtual ~Hbnd4Default () {}
           public :
             typedef hbndseg4_GEO :: bnd_t bnd_t;
@@ -122,10 +117,6 @@
 
             // default implementation returns 0
             virtual const MacroGhostInfo * buildGhostCell(ObjectStream&, int) { return 0; }
-            inline int preCoarsening  () ; 
-            inline int postRefinement () ;
-          protected:
-            Gitter * _myGrid; 
         };
         typedef Hbnd4Top < Hbnd4Default > hbndseg4_IMPL ;
 
@@ -133,9 +124,9 @@
           protected :
             typedef VertexEmpty innervertex_t ;
             inline Hedge1Empty (myvertex_t *,myvertex_t *) ;
-     ~Hedge1Empty () {}
+            ~Hedge1Empty () {}
            // Methode um einen Vertex zu verschieben; f"ur die Randanpassung
-           virtual inline void projectInnerVertex(const ProjectVertex &pv) ; 
+           virtual inline void projectInnerVertex(const ProjectVertexPair &pv) ; 
         } ;
   
         typedef Hedge1Top < Hedge1Empty > hedge1_IMPL ;
@@ -145,9 +136,9 @@
             typedef VertexEmpty   innervertex_t ;
             typedef hedge1_IMPL   inneredge_t ;
             inline Hface3Empty (myhedge1_t *,int, myhedge1_t *,int, myhedge1_t *,int) ;
-     ~Hface3Empty () {}
+           ~Hface3Empty () {}
            // Methode um einen Vertex zu verschieben; f"ur die Randanpassung
-           virtual inline void projectVertex(const ProjectVertex &pv) ; 
+           virtual inline void projectVertex(const ProjectVertexPair &pv) ; 
   } ;
         typedef Hface3Top < Hface3Empty > hface3_IMPL ;
         
@@ -160,7 +151,7 @@
            inline Hface4Empty (myhedge1_t *,int, myhedge1_t *,int, myhedge1_t *,int,myhedge1_t *,int) ;
            ~Hface4Empty () {}
            // Methode um einen Vertex zu verschieben; f"ur die Randanpassung
-           virtual inline void projectVertex(const ProjectVertex &pv) ; 
+           virtual inline void projectVertex(const ProjectVertexPair &pv) ; 
         } ;
         typedef Hface4Top < Hface4Empty > hface4_IMPL ;
 
@@ -367,7 +358,7 @@
       typedef hface3_IMPL innerface_t ;
       typedef hedge1_IMPL inneredge_t ;
       typedef VertexEmpty innervertex_t ;
-	    typedef tetra_IMPL GhostElement_t;
+      typedef tetra_IMPL GhostElement_t;
 
       inline Periodic3Empty (myhface3_t *,int,myhface3_t *,int) ;
       ~Periodic3Empty () {}
@@ -585,7 +576,7 @@
           typedef hface4_IMPL innerface_t ;
           typedef hedge1_IMPL inneredge_t ;
           typedef VertexEmpty innervertex_t ;
-	        typedef hexa_IMPL GhostElement_t;
+          typedef hexa_IMPL GhostElement_t;
 
           inline Periodic4Empty (myhface4_t *,int,myhface4_t *,int) ;
           ~Periodic4Empty () {}
@@ -605,11 +596,11 @@
         virtual inline hedge1_GEO    * insert_hedge1 (VertexGeo *, VertexGeo *) ;
         virtual inline hface3_GEO    * insert_hface3 (hedge1_GEO *(&)[3], int (&)[3]) ;
         virtual inline hface4_GEO    * insert_hface4 (hedge1_GEO *(&)[4], int (&)[4]) ;
-        virtual inline hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, Gitter :: hbndseg_STI :: bnd_t) ;
+        virtual inline hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t)       ;
         // version with point , returns insert_hbnd3 here 
-        virtual inline hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoTetra* ) ;
-        virtual inline hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, Gitter :: hbndseg_STI :: bnd_t) ;
-        virtual inline hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoHexa* ) ;
+        virtual inline hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoTetra* ) ;
+        virtual inline hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t) ;
+        virtual inline hbndseg4_GEO  * insert_hbnd4 (hface4_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoHexa* ) ;
         virtual inline tetra_GEO     * insert_tetra (hface3_GEO *(&)[4], int (&)[4]) ;
         virtual inline periodic3_GEO * insert_periodic3 (hface3_GEO *(&)[2], int (&)[2]) ;
 
@@ -630,19 +621,24 @@
 
 class GitterBasisImpl : public GitterBasis {
   MacroGitterBasis * _macrogitter ;
+  ProjectVertex*     _ppv;
   public:
    //us fuer Globalmethode levelwalk
   inline Makrogitter & container () ;
   inline const Makrogitter & container () const ;
   public :
     inline IndexManagerType & indexManager(int codim);
+    inline size_t numMacroBndSegments() const;
         
     inline GitterBasisImpl () ;
-    inline GitterBasisImpl (istream &) ;
-    inline GitterBasisImpl (const char *) ;
+    inline GitterBasisImpl (istream &, ProjectVertex* ) ;
+    inline GitterBasisImpl (const char *, ProjectVertex* ) ;
     inline ~GitterBasisImpl () ;
 
     virtual void printMemUsage ();
+
+    // return pointer to vertex projection 
+    virtual ProjectVertex* vertexProjection() const;
 } ;
 
 
@@ -684,7 +680,8 @@
   return ;
 }
 
-inline void GitterBasis :: Objects :: Hedge1Empty :: projectInnerVertex(const ProjectVertex &pv) {
+inline void GitterBasis :: Objects :: Hedge1Empty :: projectInnerVertex(const ProjectVertexPair &pv) 
+{
   if (innerVertex()) {
     assert(!leaf());
     innerVertex()->project(pv);
@@ -696,7 +693,8 @@
   return ;
 }
 
-inline void GitterBasis :: Objects :: Hface3Empty :: projectVertex(const ProjectVertex &pv) {
+inline void GitterBasis :: Objects :: Hface3Empty :: projectVertex(const ProjectVertexPair &pv) 
+{
   assert(!leaf());
   for (int e = 0; e < polygonlength; e++)
     myhedge1(e)->projectInnerVertex(pv);
@@ -710,7 +708,7 @@
   return ;
 }
 
-inline void GitterBasis :: Objects :: Hface4Empty :: projectVertex(const ProjectVertex &pv) {
+inline void GitterBasis :: Objects :: Hface4Empty :: projectVertex(const ProjectVertexPair &pv) {
   for (int e = 0; e < polygonlength; e++)
     myhedge1(e)->projectInnerVertex(pv);
   if (innerVertex())
@@ -801,48 +799,13 @@
 // end of Dune_hbndDefault 
 //***************************************************************************
 
-inline GitterBasis :: Objects :: Hbnd3Default :: Hbnd3Default (myhface3_t * f, int i, ProjectVertex *ppv, Gitter * grd ) :
-  Gitter :: Geometric :: hbndseg3_GEO (f, i, ppv) , _myGrid(grd) 
+inline GitterBasis :: Objects :: Hbnd3Default :: 
+Hbnd3Default (myhface3_t * f, int i, ProjectVertex *ppv ) 
+ : Gitter :: Geometric :: hbndseg3_GEO (f, i, ppv)
 {
   return ;
 }
 
-// calles method on grid which return 0 for default impl 
-inline int GitterBasis :: Objects :: Hbnd3Default :: preCoarsening () 
-{
-#ifdef __USE_INTERNAL_FACES__  
-  // grid pointer only exists in the case of internal bnds 
-  if(_myGrid)
-  {
-    return _myGrid->preCoarsening(*this);
-  }
-  else 
-  {
-    return 0;
-  }
-#else 
-  return 0;
-#endif
-}
-
-// calles method on grid which return 0 for default impl 
-inline int GitterBasis :: Objects :: Hbnd3Default :: postRefinement () 
-{
-#ifdef __USE_INTERNAL_FACES__  
-  // grid pointer only exists in the case of internal bnds 
-  if(_myGrid)
-  {
-    return _myGrid->postRefinement(*this);
-  }
-  else 
-  {
-    return 0;
-  }
-#else
-  return 0;
-#endif
-}
-
 inline GitterBasis :: Objects ::Hbnd3Default :: bnd_t GitterBasis :: Objects :: Hbnd3Default :: bndtype () const {
   return undefined ;
 }
@@ -851,30 +814,12 @@
   return level() ;
 }
 
-inline GitterBasis :: Objects :: Hbnd4Default :: Hbnd4Default (myhface4_t * f, int i, ProjectVertex *ppv, Gitter * grd ) : 
-  Gitter :: Geometric :: hbndseg4_GEO (f, i,ppv) , _myGrid(grd) 
+inline GitterBasis :: Objects :: Hbnd4Default :: Hbnd4Default (myhface4_t * f, int i, ProjectVertex *ppv) : 
+  Gitter :: Geometric :: hbndseg4_GEO (f, i,ppv)
 {
   return ;
 }
 
-// calles method on grid which return 0 for default impl 
-inline int GitterBasis :: Objects :: Hbnd4Default :: preCoarsening () 
-{
-  if(_myGrid)
-    return _myGrid->preCoarsening(*this);
-  else 
-    return 0;
-}
-
-// calles method on grid which return 0 for default impl 
-inline int GitterBasis :: Objects :: Hbnd4Default :: postRefinement () 
-{
-  if(_myGrid)
-    return _myGrid->postRefinement(*this);
-  else 
-    return 0;
-}
-
 inline GitterBasis :: Objects ::Hbnd4Default :: bnd_t GitterBasis :: Objects :: Hbnd4Default :: bndtype () const {
   return undefined ;
 }
@@ -954,21 +899,27 @@
 
 // Ende - Neu 29.4.05
 
-inline GitterBasisImpl :: GitterBasisImpl () : _macrogitter (0) {
+inline GitterBasisImpl :: GitterBasisImpl () : _macrogitter (0) , _ppv(0) 
+{
   _macrogitter = new MacroGitterBasis ( this ) ;
   assert (_macrogitter) ;
   notifyMacroGridChanges () ;
   return ;
 }
 
-inline GitterBasisImpl :: GitterBasisImpl (istream & in) : _macrogitter (0) {
+inline GitterBasisImpl :: GitterBasisImpl (istream & in, ProjectVertex* ppv) 
+  : _macrogitter (0) , _ppv( ppv ) 
+{
   _macrogitter = new MacroGitterBasis ( this , in) ;
   assert (_macrogitter) ;
   notifyMacroGridChanges () ;
   return ;
 }
 
-inline GitterBasisImpl :: GitterBasisImpl (const char * file) : _macrogitter (0) {
+inline GitterBasisImpl :: GitterBasisImpl (const char * file, 
+                                           ProjectVertex* ppv) 
+: _macrogitter (0), _ppv( ppv ) 
+{
   ifstream in (file) ;
   if (!in) {
     cerr << "  GitterBasisImpl :: GitterBasisImpl (const char *) FEHLER (IGNORIERT) " ;
@@ -987,6 +938,11 @@
   return ;
 }
 
+inline ProjectVertex*  GitterBasisImpl :: vertexProjection() const 
+{
+  return _ppv;
+}
+
 inline Gitter :: Makrogitter & GitterBasisImpl :: container () {
   return * _macrogitter ;
 }
@@ -1000,8 +956,15 @@
   return _macrogitter->indexManager(codim);
 }
 
-inline GitterBasis :: MacroGitterBasis :: MacroGitterBasis (Gitter * mygrid, istream & in) : _myGrid(mygrid) {
-  macrogridBuilder (in) ;
+inline size_t GitterBasisImpl :: numMacroBndSegments() const
+{ 
+  return _macrogitter->numMacroBndSegments();
+}
+
+inline GitterBasis :: MacroGitterBasis :: MacroGitterBasis (Gitter * mygrid, istream & in) 
+  : _myGrid(mygrid) 
+{
+  macrogridBuilder (in, _myGrid->vertexProjection() ) ;
   return ;
 }
 
@@ -1101,28 +1064,32 @@
 }
 
 inline GitterBasis :: hbndseg3_GEO * GitterBasis :: MacroGitterBasis :: 
-insert_hbnd3 (hface3_GEO * f, int i, Gitter :: hbndseg_STI :: bnd_t b) 
+insert_hbnd3 (hface3_GEO * f, int i, 
+              ProjectVertex* ppv, 
+              Gitter :: hbndseg_STI :: bnd_t b) 
 {
-  // the two last zeros are the following: 
-  // the first pointer is pointer to grid which we dont need in the serial
-  // case and the second is a pointer to ghost Element 
-  return new Objects :: hbndseg3_IMPL ( 0,f,i, NULL,NULL, b, indexManager(IM_Bnd), _myGrid) ;
+  // the NULL pointer is the pointer to the father which does not exists 
+  return new Objects :: hbndseg3_IMPL ( 0, f, i, ppv, b, indexManager(IM_Bnd) ) ;
 }
 
 inline GitterBasis :: hbndseg3_GEO * GitterBasis :: MacroGitterBasis :: 
-insert_hbnd3 (hface3_GEO * f, int i, Gitter :: hbndseg_STI :: bnd_t b, MacroGhostInfoTetra* ) {
-  return insert_hbnd3(f,i,b); 
+insert_hbnd3 (hface3_GEO * f, int i, ProjectVertex* ppv, 
+              Gitter :: hbndseg_STI :: bnd_t b, MacroGhostInfoTetra* ) 
+{
+  return insert_hbnd3(f,i,ppv,b); 
 }
 
 inline GitterBasis :: hbndseg4_GEO * GitterBasis :: MacroGitterBasis :: 
-insert_hbnd4 (hface4_GEO * f, int i, Gitter :: hbndseg_STI :: bnd_t b) 
+insert_hbnd4 (hface4_GEO * f, int i, ProjectVertex* ppv, Gitter :: hbndseg_STI :: bnd_t b) 
 {
-  return new Objects :: hbndseg4_IMPL ( 0,f,i,NULL, b,indexManager(IM_Bnd) );
+  return new Objects :: hbndseg4_IMPL ( 0, f, i, ppv, b, indexManager(IM_Bnd) );
 }
 
 inline GitterBasis :: hbndseg4_GEO * GitterBasis :: MacroGitterBasis :: 
-insert_hbnd4 (hface4_GEO * f, int i, Gitter :: hbndseg_STI :: bnd_t b, MacroGhostInfoHexa* ) {
-  return insert_hbnd4 (f,i,b); 
+insert_hbnd4 (hface4_GEO * f, int i, ProjectVertex* ppv,
+              Gitter :: hbndseg_STI :: bnd_t b, MacroGhostInfoHexa* ) 
+{
+  return insert_hbnd4 (f,i,ppv,b); 
 }
 
 inline void GitterBasisImpl :: printMemUsage ()
Index: serial/ghost_elements.h
===================================================================
--- serial/ghost_elements.h	(revision 1064)
+++ serial/ghost_elements.h	(revision 1173)
@@ -31,7 +31,7 @@
   MacroGhostBuilder(const MacroGhostBuilder& );
 public:  
   // constructor 
-  MacroGhostBuilder (BuilderIF & bi) : MacroGridBuilder(bi,false) 
+  MacroGhostBuilder (BuilderIF & bi) : MacroGridBuilder(bi,(bool) false) 
   {
     // create Builder with empty lists 
     this->_initialized = true;
Index: serial/gitter_mgb.cc
===================================================================
--- serial/gitter_mgb.cc	(revision 1064)
+++ serial/gitter_mgb.cc	(revision 1173)
@@ -143,8 +143,8 @@
   else 
   {
     if (_hbnd3Map.find (key) == _hbnd3Map.end ()) {
-      hface3_GEO * face =  InsertUniqueHface3 (v).first ;
-      hbndseg3_GEO * hb3 = myBuilder ().insert_hbnd3 (face,twst,bt) ;
+      hface3_GEO * face  = InsertUniqueHface3 (v).first ;
+      hbndseg3_GEO * hb3 = myBuilder ().insert_hbnd3 (face,twst, _ppv, bt) ;
       _hbnd3Map [key] = hb3 ;
       return true ;
     }
@@ -155,16 +155,20 @@
 bool MacroGridBuilder :: InsertUniqueHbnd4 (int (&v)[4], Gitter :: hbndseg_STI ::bnd_t bt) {
   int twst = cyclicReorder (v,v+4) ;
   faceKey_t key (v [0], v [1], v [2]) ;
-  if (bt == Gitter :: hbndseg_STI :: closure) {
+  if (bt == Gitter :: hbndseg_STI :: closure) 
+  {
     if (_hbnd4Int.find (key) == _hbnd4Int.end ()) {
       hface4_GEO * face =  InsertUniqueHface4 (v).first ;
       _hbnd4Int [key] = new Hbnd4IntStorage (face,twst) ;
       return true ;
     }
-  } else {
-    if (_hbnd4Map.find (key) == _hbnd4Map.end ()) {
+  } 
+  else 
+  {
+    if (_hbnd4Map.find (key) == _hbnd4Map.end ()) 
+    {
       hface4_GEO * face =  InsertUniqueHface4 (v).first ;
-      hbndseg4_GEO * hb4 = myBuilder ().insert_hbnd4 (face,twst,bt) ;
+      hbndseg4_GEO * hb4 = myBuilder ().insert_hbnd4 (face,twst, _ppv, bt) ;
       _hbnd4Map [key] = hb4 ;
       return true ;
     }
@@ -604,12 +608,22 @@
 }
 
 // default of init == true
-MacroGridBuilder :: MacroGridBuilder (BuilderIF & b, bool init) 
- : _initialized(false) , _finalized(false) , _mgb (b) 
+MacroGridBuilder :: MacroGridBuilder (BuilderIF & b, const bool init) 
+ : _initialized(false) 
+ , _finalized(false) 
+ , _ppv( NULL ), _mgb (b) 
 {
   if(init) initialize();
 }
 
+MacroGridBuilder :: MacroGridBuilder (BuilderIF & b, ProjectVertex* ppv) 
+ : _initialized(false) 
+ , _finalized(false) 
+ , _ppv( ppv ), _mgb (b) 
+{
+  initialize();
+}
+
 void MacroGridBuilder :: initialize () 
 {
   {
@@ -744,7 +758,9 @@
     for (hbnd4intMap_t :: iterator i = _hbnd4Int.begin () ; i != _hbnd4Int.end () ; i ++) {
     const Hbnd4IntStorage & p = * ((*i).second);
     if (p.first()->ref == 1) {
-      hbndseg4_GEO * hb4 = myBuilder ().insert_hbnd4 (p.first(),p.second(),Gitter :: hbndseg_STI :: closure) ;
+      hbndseg4_GEO * hb4 = 
+        myBuilder ().insert_hbnd4 (p.first(), p.second(), NULL, 
+                                   Gitter :: hbndseg_STI :: closure) ;
       myBuilder ()._hbndseg4List.push_back (hb4) ;
     }
     delete (*i).second;
@@ -754,7 +770,8 @@
   {for (hbnd3intMap_t :: iterator i = _hbnd3Int.begin () ; i != _hbnd3Int.end () ; i ++) {
     const Hbnd3IntStorage & p = * ((*i).second);
     if (p.first()->ref == 1) {
-      hbndseg3_GEO * hb3 = myBuilder ().insert_hbnd3 (p.first(),p.second(),Gitter :: hbndseg_STI :: closure) ;    
+      hbndseg3_GEO * hb3 = 
+        myBuilder ().insert_hbnd3 (p.first(),p.second(), NULL, Gitter :: hbndseg_STI :: closure) ;    
       myBuilder ()._hbndseg3List.push_back (hb3) ;
     }
     delete (*i).second;
@@ -910,9 +927,15 @@
   return ;
 }
 
-void Gitter :: Geometric :: BuilderIF :: macrogridBuilder (istream & in) {
+void Gitter :: Geometric :: BuilderIF :: macrogridBuilder (istream & in, ProjectVertex* ppv) 
+{
   strstream_t raw ;
-  MacroGridBuilder mm (*this) ;
+  
+  // set scientific mode and high precision 
+  raw << scientific ;
+  raw.precision( 16 );
+
+  MacroGridBuilder mm (*this, ppv) ;
   int c = in.get () ;
   assert (!in.eof ()) ;
   in.putback (c) ;
@@ -955,7 +978,9 @@
       return ;
     }
     delete [] str ;
-  } else {
+  } 
+  else 
+  {
     cerr << "**WARNING (IGNORED) No identifier for file format found!\n" ;
     cerr << "  -> Try to read as hexa mesh." << endl ;
     MacroGridBuilder :: generateRawHexaImage (in,raw) ;
Index: serial/gitter_mgb.h
===================================================================
--- serial/gitter_mgb.h	(revision 1064)
+++ serial/gitter_mgb.h	(revision 1173)
@@ -111,7 +111,7 @@
     hbnd4intMap_t _hbnd4Int; 
     
     elementMap_t _hexaMap, _tetraMap, _periodic3Map, _periodic4Map ;
-    
+
     inline BuilderIF & myBuilder () ;
     inline const BuilderIF & myBuilder () const ;
     void removeElement (const elementKey_t &) ;
@@ -134,7 +134,8 @@
     static void generateRawHexaImage (istream &, ostream &) ;
     static void generateRawTetraImage (istream &, ostream &) ;
     static void cubeHexaGrid (int, ostream &) ;
-    MacroGridBuilder (BuilderIF &, bool init = true) ;
+    MacroGridBuilder (BuilderIF &, const bool init = true) ;
+    MacroGridBuilder (BuilderIF &, ProjectVertex* );
     virtual ~MacroGridBuilder () ;
     void inflateMacroGrid (istream &) ;
     void backupMacroGrid (ostream &) ;
@@ -146,6 +147,10 @@
   protected:  
     bool _initialized;
     bool _finalized;
+
+    // Vertex projection 
+    ProjectVertex* _ppv; 
+
   private :
     BuilderIF & _mgb ;
 } ;
Index: serial/gitter_hexa_top.h
===================================================================
--- serial/gitter_hexa_top.h	(revision 1064)
+++ serial/gitter_hexa_top.h	(revision 1173)
@@ -144,6 +144,7 @@
     IndexManagerType & _indexManager;
     int _lvl ;
     const bnd_t _bt; // type of boundary 
+    int _segmentIndex; // index of macro boundary segment 
     
     inline bool coarse () ;
     inline void append (innerbndseg_t *) ;
@@ -151,16 +152,15 @@
     // constructor for refinement 
     inline Hbnd4Top (int,myhface4_t *,int,ProjectVertex *, innerbndseg_t *, Gitter::helement_STI *, int) ;
 
-    // constructor for macro element
-    inline Hbnd4Top (int,myhface4_t *,int,ProjectVertex *, const bnd_t bt , IndexManagerType & , Gitter * ) ;
-
     // constructor for macro element in the serial case 
     inline Hbnd4Top (int,myhface4_t *,int,ProjectVertex *, const bnd_t bt , IndexManagerType & ) ;
+
     virtual ~Hbnd4Top () ;
     bool refineBalance (balrule_t,int) ;
     bool bndNotifyCoarsen () ;
     void restoreFollowFace () ;
     int level () const ;
+    int segmentIndex () const ;
     innerbndseg_t * next () ;
     innerbndseg_t * down () ;
     const innerbndseg_t * next () const ;
@@ -834,13 +834,10 @@
       abort () ;
       break ;
     }
-// ?? // Die nichtkonforme Nachbarschaft noch erg"anzen und auf der
-// ?? // Fl"ache die Situation nach der Verfeinerung vervollst"andigen.
-// ?? 
-// ??   {for (innerface_t * f = down () ; f ; f = f->next ()) f->nb = nb ; }
 
     // * higher order, this is a hack
-    for (innerface_t* f = down(); f; f = f->next()) { //, ++i) {
+    for (innerface_t* f = down(); f; f = f->next()) 
+    { 
       f->_parRule = getrule();
     }
 
@@ -967,36 +964,32 @@
 template < class A > inline Hbnd4Top < A > :: 
 Hbnd4Top (int l, myhface4_t * f, int i, ProjectVertex *ppv, 
           innerbndseg_t * up, Gitter::helement_STI * gh, int gFace ) : 
-  A (f, i,ppv,up->_myGrid), _bbb (0), _dwn (0), _up(up) , 
+  A (f, i, ppv), _bbb (0), _dwn (0), _up(up) , 
   _indexManager(_up->_indexManager) ,
-  _lvl (l), _bt(_up->_bt)
+  _lvl (l), 
+  _bt(_up->_bt),
+  _segmentIndex( _up->_segmentIndex ) // get segment index from father 
 {
   typedef Gitter :: ghostpair_STI ghostpair_STI;
   ghostpair_STI p ( gh, gFace );
   this->setGhost ( p );
   this->setIndex( _indexManager.getIndex() );  
+
   setBoundaryId( _bt );
   return ;
 }
 
 template < class A > inline Hbnd4Top < A > :: 
-Hbnd4Top (int l, myhface4_t * f, int i, ProjectVertex *ppv, const bnd_t bt , IndexManagerType & im , Gitter * grd )
-  : A (f, i,ppv,grd), _bbb (0), _dwn (0), _up(0) , 
+Hbnd4Top (int l, myhface4_t * f, int i, ProjectVertex *ppv, const bnd_t bt , IndexManagerType & im)
+  : A (f, i, ppv), _bbb (0), _dwn (0), _up(0) , 
   _indexManager(im) ,
   _lvl (l) , _bt(bt)  
 {
   this->setIndex( _indexManager.getIndex() );  
-  setBoundaryId( _bt );
-  return ;
-}
 
-template < class A > inline Hbnd4Top < A > :: 
-Hbnd4Top (int l, myhface4_t * f, int i, ProjectVertex *ppv, const bnd_t bt , IndexManagerType & im )
-  : A (f, i,ppv, 0 ), _bbb (0), _dwn (0), _up(0) , 
-  _indexManager(im) ,
-  _lvl (l) , _bt(bt) 
-{
-  this->setIndex( _indexManager.getIndex() );  
+  // store segment by using index 
+  _segmentIndex = this->getIndex() ;
+
   setBoundaryId( _bt );
   return ;
 }
@@ -1022,6 +1015,10 @@
   }
 }
 
+template < class A > inline int Hbnd4Top < A > :: segmentIndex () const {
+  return _segmentIndex ;
+}
+
 template < class A > inline int Hbnd4Top < A > :: level () const {
   return _lvl ;
 }
@@ -1094,15 +1091,15 @@
   void* bndMem[8] = {0,0,0,0};
   this->mallocAtOnce( sizeof(innerbndseg_t), bndMem, 4 );
 
-  innerbndseg_t * b0 = new (bndMem[0]) innerbndseg_t (l, this->subface4 (0,0), this->twist (0), this->projection, this, ghostInfo.child(0), ghostInfo.face(0)) ;
-  innerbndseg_t * b1 = new (bndMem[1]) innerbndseg_t (l, this->subface4 (0,1), this->twist (0), this->projection, this, ghostInfo.child(1), ghostInfo.face(1)) ;
-  innerbndseg_t * b2 = new (bndMem[2]) innerbndseg_t (l, this->subface4 (0,2), this->twist (0), this->projection, this, ghostInfo.child(2), ghostInfo.face(2)) ;
-  innerbndseg_t * b3 = new (bndMem[3]) innerbndseg_t (l, this->subface4 (0,3), this->twist (0), this->projection, this, ghostInfo.child(3), ghostInfo.face(3)) ;
+  innerbndseg_t * b0 = new (bndMem[0]) innerbndseg_t (l, this->subface4 (0,0), this->twist (0), this->_projection, this, ghostInfo.child(0), ghostInfo.face(0)) ;
+  innerbndseg_t * b1 = new (bndMem[1]) innerbndseg_t (l, this->subface4 (0,1), this->twist (0), this->_projection, this, ghostInfo.child(1), ghostInfo.face(1)) ;
+  innerbndseg_t * b2 = new (bndMem[2]) innerbndseg_t (l, this->subface4 (0,2), this->twist (0), this->_projection, this, ghostInfo.child(2), ghostInfo.face(2)) ;
+  innerbndseg_t * b3 = new (bndMem[3]) innerbndseg_t (l, this->subface4 (0,3), this->twist (0), this->_projection, this, ghostInfo.child(3), ghostInfo.face(3)) ;
 #else
-  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface4 (0,0), this->twist (0), this->projection, this, ghostInfo.child(0), ghostInfo.face(0)) ;
-  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface4 (0,1), this->twist (0), this->projection, this, ghostInfo.child(1), ghostInfo.face(1)) ;
-  innerbndseg_t * b2 = new innerbndseg_t (l, this->subface4 (0,2), this->twist (0), this->projection, this, ghostInfo.child(2), ghostInfo.face(2)) ;
-  innerbndseg_t * b3 = new innerbndseg_t (l, this->subface4 (0,3), this->twist (0), this->projection, this, ghostInfo.child(3), ghostInfo.face(3)) ;
+  innerbndseg_t * b0 = new innerbndseg_t (l, this->subface4 (0,0), this->twist (0), this->_projection, this, ghostInfo.child(0), ghostInfo.face(0)) ;
+  innerbndseg_t * b1 = new innerbndseg_t (l, this->subface4 (0,1), this->twist (0), this->_projection, this, ghostInfo.child(1), ghostInfo.face(1)) ;
+  innerbndseg_t * b2 = new innerbndseg_t (l, this->subface4 (0,2), this->twist (0), this->_projection, this, ghostInfo.child(2), ghostInfo.face(2)) ;
+  innerbndseg_t * b3 = new innerbndseg_t (l, this->subface4 (0,3), this->twist (0), this->_projection, this, ghostInfo.child(3), ghostInfo.face(3)) ;
 #endif 
   assert (b0 && b1 && b2 && b3) ;
   b0->append(b1) ;
@@ -1112,8 +1109,8 @@
   return ;
 }
 
-template < class A > inline bool Hbnd4Top < A > :: refineBalance (balrule_t r, int b) {
-
+template < class A > inline bool Hbnd4Top < A > :: refineBalance (balrule_t r, int b) 
+{
   // Die Methode refineBalance () f"uhrt auf dem Randabschluss entweder
   // unbedingt die Verfeinerung durch, da im Verlauf der Verfeinerung keine
   // weiteren Anforerungen mehr an den Randabschluss  gerichtet werden 
@@ -1122,43 +1119,49 @@
 
   assert (b == 0) ;
   assert (this->leaf ()) ;
-  if (! bndNotifyBalance (r,b)) {
-  
+  if (! bndNotifyBalance (r,b)) 
+  {
     // Hier kann der innere Rand [parallel] die Verfeinerung
-  // verhindern, damit z.B. das Durchverfeinern im anisotropen
-  // Fall erstmal nicht stattfindet, wenn nicht klar ist, wie die
-  // weitere Rekursion aussieht. Dazu muss auf dem Niveau der Klasse
-  // des Template-Arguments die Methode bndNotifyBalance () "uber-
-  // schrieben werden. Die Defaultmethode liefert immer 'true'.
-  
+    // verhindern, damit z.B. das Durchverfeinern im anisotropen
+    // Fall erstmal nicht stattfindet, wenn nicht klar ist, wie die
+    // weitere Rekursion aussieht. Dazu muss auf dem Niveau der Klasse
+    // des Template-Arguments die Methode bndNotifyBalance () "uber-
+    // schrieben werden. Die Defaultmethode liefert immer 'true'.
+    
     return false ;
-  } else {
-    if(r == myrule_t :: iso4) {
-    
+  } 
+  else 
+  {
+    if(r == myrule_t :: iso4) 
+    {
       // Der Rand verfeinert unbedingt die anliegende Fl"ache und dann
-  // sich selbst, weil die Anforderung durch die Fl"ache kam, und
-  // dahinter keine Balancierung stattfinden muss.
+      // sich selbst, weil die Anforderung durch die Fl"ache kam, und
+      // dahinter keine Balancierung stattfinden muss.
     
+      // refine face 
       this->myhface4 (0)->refineImmediate (r) ;
+      // refine myself 
       splitISO4 () ;
-    } else {
+    } 
+    else 
+    {
       cerr << "**FEHLER (FATAL, weil nicht vorgesehen) beim Verfeinern am " ;
       cerr << "Randst\"uck mit der Regel [" << r << "] in " ;
       cerr << __FILE__ << " " << __LINE__ << endl ;
       abort () ;
     }
     
-      // postRefinement () gibt die M"oglichkeit auf dem Niveau des
-  // Template-Arguments eine Methode aufzurufen, um eventuelle
-  // Operationen auf dem verfeinerten Randst"uck aufzurufen.
+    // postRefinement () gibt die M"oglichkeit auf dem Niveau des
+    // Template-Arguments eine Methode aufzurufen, um eventuelle
+    // Operationen auf dem verfeinerten Randst"uck aufzurufen.
     
     this->postRefinement () ;
     return true ;
   }
 }
 
-template < class A > inline bool Hbnd4Top < A > :: refineLikeElement (balrule_t r) {
-
+template < class A > inline bool Hbnd4Top < A > :: refineLikeElement (balrule_t r) 
+{
   // Mit der Methode refineLikeElement () verh"alt sich ein Randabschluss
   // in der Verfeinerung wie ein Element: Es wird zuerst gepr"uft ob eine
   // Balancierung der Vererfeinerung durch die Fl"ache hindurch erfolgreich
@@ -1170,32 +1173,44 @@
   // aufgel"ost ist. Erst die mehrfache Anwendung f"uhrt durch die 
   // Balancierung zu einer "Anderung am Elementgitter.
 
-  if (r == myrule_t :: nosplit) {
+  if (r == myrule_t :: nosplit) 
+  {
     cerr << "**WARNUNG (IGNORIERT) beim Versuch mit nosplit zu Verfeinern" ;
     cerr << "  in " << __FILE__ << " " << __LINE__ << endl ;
     
-      // Eine Anforderung mit nosplit zu Verfeinern nur erf"ullt,
-  // falls die zugeh"orige Fl"achenregel auch nosplit ist, sonst
-  // wird die Anforderung als nicht erf"ullt zur"uckgegeben.
+    // Eine Anforderung mit nosplit zu Verfeinern nur erf"ullt,
+    // falls die zugeh"orige Fl"achenregel auch nosplit ist, sonst
+    // wird die Anforderung als nicht erf"ullt zur"uckgegeben.
     
     return this->getrule () == balrule_t :: nosplit ? true : false ;
-  } else {
-    if (this->getrule () == r) {
-    
+  } 
+  else 
+  {
+    if (this->getrule () == r) 
+    {
       // Alles schon wie es sein soll -> true.
-    
       return true ;
-    } else {
-  
-  // Der nachfolgende Test bezieht sich auf die Verfeinerungssituation
-  // der Fl"ache, da getrule () auf myhface4 (0)->getrule () umgeleitet
-  // ist.
-  
+    } 
+    else 
+    {
+      // Der nachfolgende Test bezieht sich auf die Verfeinerungssituation
+      // der Fl"ache, da getrule () auf myhface4 (0)->getrule () umgeleitet
+      // ist.
+      
       assert (this->getrule () == myrule_t :: nosplit) ;
-      switch (r) {
+      switch (r) 
+      {
       case balrule_t :: iso4 :
         if (! this->myhface4 (0)->refine(balrule_t (balrule_t :: iso4).rotate (this->twist (0)), this->twist (0))) return false ;
+
+        // call refinement method 
         splitISO4 () ;
+
+        // postRefinement () gibt die M"oglichkeit auf dem Niveau des
+        // Template-Arguments eine Methode aufzurufen, um eventuelle
+        // Operationen auf dem verfeinerten Randst"uck aufzurufen.
+        this->postRefinement () ;
+
         return true ;
       default :
         cerr << "**WARNUNG (FEHLER IGNORIERT) falsche Verfeinerungsregel [" << this->getrule () ;
@@ -1206,28 +1221,33 @@
   }
 }
 
-template < class A > void Hbnd4Top < A > :: restoreFollowFace () {
-
+template < class A > void Hbnd4Top < A > :: restoreFollowFace () 
+{
   // retoreFollowFace () veranlasst das Randelement sich am 
   // bestehenden Fl"achenbaum wiederherzustellen durch die
   // entsprechende Verfeinerung.
   
   myhface4_t & f (*(this->myhface4 (0))) ;
-  if (!f.leaf ()) {
+  if (!f.leaf ()) 
+  {
     balrule_t r = f.getrule () ;
-    switch (r) {
+    switch (r) 
+    {
       case myrule_t :: iso4 :
         splitISO4 () ;
-  break ;
+        break ;
       default :
         cerr << "**FEHLER (FATAL, weil nicht vorgesehen) beim Verfeinern am " ;
         cerr << "Randst\"uck mit der Regel [" << r << "] in " ;
         cerr << __FILE__ << " " << __LINE__ << endl ;
         abort () ;
-  break ;
+        break ;
     }
+    // do post refinement 
     this->postRefinement () ;
-    {for (innerbndseg_t * b = down () ; b ; b = b->next ()) b->restoreFollowFace () ; }
+    {
+      for (innerbndseg_t * b = down () ; b ; b = b->next ()) b->restoreFollowFace () ; 
+    }
   }
   return ;
 }
@@ -1278,7 +1298,7 @@
   , _lvl (l)
   , _rule (myrule_t :: nosplit), _req (myrule_t :: nosplit) 
   , _nChild(0) 
-  , _affine(false)
+  , _affine( false )
 { 
   TrilinearMapping trMap (this->myvertex(0)->Point(), this->myvertex(1)->Point(),
                           this->myvertex(2)->Point(), this->myvertex(3)->Point(),
@@ -1288,7 +1308,7 @@
   _volume = QuadraturCube3D < VolumeCalc > (trMap).integrate2 (0.0);
   // check whether mapping is affine 
   _affine = trMap.affine(); 
-  
+
   assert( this->level() == l );
   
   this->setIndex( _indexManager.getIndex() );   
@@ -1319,16 +1339,23 @@
   // if mapping is not affine recalculate volume 
   if( ! _affine )
   {
+    TrilinearMapping triMap (this->myvertex(0)->Point(),
+                             this->myvertex(1)->Point(),
+                             this->myvertex(2)->Point(),
+                             this->myvertex(3)->Point(),
+                             this->myvertex(4)->Point(),
+                             this->myvertex(5)->Point(),
+                             this->myvertex(6)->Point(),
+                             this->myvertex(7)->Point() );
+
+#ifndef NDEBUG 
+    // make sure determinant is ok 
+    double point[3] = { 0.0, 0.0, 0.0 };
+    assert( triMap.det( point ) > 0 );
+#endif
+
     // calculate volume 
-    _volume = QuadraturCube3D < VolumeCalc >
-                (TrilinearMapping (this->myvertex(0)->Point(), 
-                                   this->myvertex(1)->Point(),
-                                   this->myvertex(2)->Point(), 
-                                   this->myvertex(3)->Point(),
-                                   this->myvertex(4)->Point(), 
-                                   this->myvertex(5)->Point(),
-                                   this->myvertex(6)->Point(), 
-                                   this->myvertex(7)->Point())).integrate2 (0.0);
+    _volume = QuadraturCube3D < VolumeCalc > (triMap).integrate2 (0.0);
   }
 
   // make sure that given volume is the same as calulated 
@@ -1530,6 +1557,22 @@
   // calculate child volume which is volume divided by 8 
   double childVolume = 0.125 * _volume;
 
+  // only check for affine faces 
+  // for other it does not matter 
+  if( _affine ) 
+  {
+    // if vertex projection is available
+    // then set affine to false to invoke volume calculation  
+    for( int i=0; i<6; ++i) 
+    {
+      if( this->myneighbour( i ).first->hasVertexProjection() )
+      {
+        _affine = false ; 
+        break ;
+      }
+    }
+  }
+
 #ifdef USE_MALLOC_AT_ONCE
   void* hexaMem[8] = {0,0,0,0,0,0,0,0};
   this->mallocAtOnce( sizeof(innerhexa_t), hexaMem, 8 );
Index: serial/gitter_geo.cc
===================================================================
--- serial/gitter_geo.cc	(revision 1064)
+++ serial/gitter_geo.cc	(revision 1173)
@@ -876,6 +876,14 @@
   return _indexmanager[ codim ];
 }
 
+size_t Gitter :: Geometric :: BuilderIF :: numMacroBndSegments() const 
+{
+  return _hbndseg3List.size() + 
+         _hbndseg4List.size() + 
+         _periodic3List.size() +
+         _periodic4List.size();
+}
+
 // compress all index manager 
 void Gitter :: Geometric :: BuilderIF :: compressIndexManagers()
 {
Index: serial/serialize.h
===================================================================
--- serial/serialize.h	(revision 1064)
+++ serial/serialize.h	(revision 1173)
@@ -61,8 +61,12 @@
   // return size of bytes allready written to stream 
   inline int size() const { return _wb; }
 
-  // reserve s bytes memory 
-  inline void reserve(size_t s) { if (s > _len) reallocateBuffer(s); }
+  // make sure that s bytes memory can be wrote without reallocation 
+  inline void reserve(size_t s) 
+  { 
+    const size_t newSize = _wb + s ;
+    if (newSize > _len) reallocateBuffer( newSize); 
+  }
 
   // delete stream 
   inline ~ObjectStreamImpl () { removeObj(); }
@@ -137,7 +141,10 @@
   inline void removeObject(const size_t length) throw (EOFException) 
   {
     _rb += length; 
+#ifndef NO_OBJECTSTREAM_DEBUG 
     if( _rb > _wb) throw EOFException () ;
+#endif
+    assert( _rb <= _wb );
   }
  
   //! free allocated memory 
@@ -147,10 +154,13 @@
   }
  
   // static alloc of char buffer for use in mpAccess_MPI 
-  inline static char * allocateBuffer(size_t newSize) throw (OutOfMemoryException)
+  inline static char * allocateBuffer(const size_t newSize) throw (OutOfMemoryException)
   {
-    // make sure that char has size of 1, otherwise check doExchange in
-    // mpAccess_MPI.cc 
+    // do nothing for size = 0
+    if( newSize == 0 ) return 0;
+
+    // make sure that char has size of 1, 
+    // otherwise check doExchange in mpAccess_MPI.cc 
     char * buffer = (char *) malloc (newSize * sizeof(char)) ;
     if ( ! buffer ) 
     {
@@ -160,11 +170,11 @@
     return buffer;
   }
   
-  // static free for use in mpAccess_MPI 
+  // static free for use with all buffers here  
   inline static void freeBuffer(char * buffer)
   {
-    assert( buffer );
-    free ( buffer );
+    // free buffer if not zero 
+    if( buffer ) free( buffer );
   }
 protected:
   inline char * getBuff (const size_t ap) { return (_buf + ap); }
@@ -186,7 +196,7 @@
   // delete buffer 
   inline void removeObj() 
   {
-    if( _buf && _owner ) free (_buf) ;
+    if( _owner ) freeBuffer( _buf );
     _buf = 0; _len = 0; _wb = 0; _rb = 0; _owner = true;
     return ;
   }
@@ -216,7 +226,7 @@
     assert( _owner );
     if( length == 0 ) return ;
 
-    size_t newWb = _wb + length;
+    const size_t newWb = _wb + length;
     if (newWb > _len) reallocateBuffer(newWb);
     
     memcpy( getBuff(_wb) , buff , length );
Index: alugrid_2d.h
===================================================================
--- alugrid_2d.h	(revision 1064)
+++ alugrid_2d.h	(revision 1173)
@@ -6,6 +6,8 @@
 
 #include "indexstack.h"
 
+#include "projectvertex.h"
+
 namespace ALUGridSpace { 
 
 #include "alu2d/grid.h"
Index: alu2d/handle.h
===================================================================
--- alu2d/handle.h	(revision 1064)
+++ alu2d/handle.h	(revision 1173)
@@ -824,6 +824,8 @@
     Listagency < macroelement_t > mel ;
 
     Listagency < macrobndel_t >  mbl;
+
+    const ProjectVertex_t  *_projectVertex; 
     
     Listwalk < helement_t > * walk( helement_t *) { return new Leafwalk < Element > (mel) ; }
 
@@ -852,9 +854,17 @@
    Hmesh_basic() : 
       vl(this), 
       mel(this), 
-      mbl(this) 
+      mbl(this),
+      _projectVertex( 0 )
    {}
 
+   Hmesh_basic(const ProjectVertex_t* pv) : 
+      vl(this), 
+      mel(this), 
+      mbl(this),
+      _projectVertex( pv )
+   {}
+
    virtual ~Hmesh_basic() {}     
 
    int getIndex(int indextype) 
@@ -868,6 +878,31 @@
      assert( indextype >= 0 && indextype < numOfIndexManager2d );
      indexmanager[indextype].freeIndex(index);
    }
+
+   // return number of macro boundary segments 
+   size_t numMacroBndSegments() const 
+   {
+     return mbl.size();
+   }
+
+   // project vertex for given boundary segment 
+   void projectVertex(const int segmentIndex, double (&point) [2]) const 
+   {
+     if( _projectVertex ) 
+     {
+       assert( segmentIndex >= 0 );
+       // copy point 
+       const double oldp[2] = { point[0], point[1] };
+       // call projection operator 
+       (*_projectVertex)( oldp, segmentIndex, point );
+     }
+   }
+
+   // set vertex projection pointer 
+   void setVertexProjection(const ProjectVertex_t* ppv)
+   {
+     _projectVertex = ppv ;
+   }
    
    // return current size of used indices 
    int indexManagerSize (int cd) const 
@@ -877,19 +912,19 @@
      return indexmanager[cd].getMaxIndex();
    }
    
-    void makeneighbours() ;
+   void makeneighbours() ;
            
-    virtual void refresh() { }
+   virtual void refresh() { }
        
-  friend class Listwalkptr < helement_t > ;
+   friend class Listwalkptr < helement_t > ;
  
-  friend class Listwalkptr < Vertex > ;
+   friend class Listwalkptr < Vertex > ;
   
-  friend class Listwalkptr < hbndel_t > ;
+   friend class Listwalkptr < hbndel_t > ;
 
-  friend class Listwalkptr < macroelement_t > ;
+   friend class Listwalkptr < macroelement_t > ;
 
-} ;
+};
 
 class Hmesh : public Hmesh_basic {
 
@@ -905,6 +940,8 @@
 
   Prolong_basic *_pro_el;
   Restrict_basic *_rest_el;
+
+
   nconf_vtx_t *ncv;
 
   void setup_grid(const char *);
Index: alu2d/vtx_btree.cc
===================================================================
--- alu2d/vtx_btree.cc	(revision 1064)
+++ alu2d/vtx_btree.cc	(revision 1173)
@@ -34,7 +34,9 @@
       insertNode(node->next, newNode);
     else
       node->next = newNode;
-  } else {
+  } 
+  else 
+  {
     if( node->prev != 0 )
       insertNode(node->prev, newNode);
     else
@@ -53,7 +55,8 @@
 Vtx_btree::left() const
 {
   Vtx_btree* left = 0;
-  if( head->prev ) {
+  if( head->prev ) 
+  {
     left = new Vtx_btree(rvtx,lnb,rnb);
     left->head = head->prev;
   }
@@ -69,7 +72,8 @@
 Vtx_btree::right() const
 {
   Vtx_btree* right = 0;
-  if( head->next ) {
+  if( head->next ) 
+  {
     right = new Vtx_btree(head->vtx,head->lnb,head->rnb);
     right->head = head->next;
   }
Index: alu2d/hdlrw.cc
===================================================================
--- alu2d/hdlrw.cc	(revision 1064)
+++ alu2d/hdlrw.cc	(revision 1173)
@@ -162,9 +162,8 @@
     x_axis = new axis_struct[nb];
     y_axis = new axis_struct[nb];
 
-    for( int i = 0 ; i <  nb ; i ++ ) 
+    for( int i = 0 ; i <  nb ; ++i ) 
     {
-
       int lt;
       
       lt=in.peek();
@@ -177,17 +176,17 @@
 
       switch (t)
       {
-  case Bndel::periodic:
-          b=new Bndel_periodic();
-    break;
-  case Bndel::general_periodic:
-    t=Bndel::periodic;
-          b=new Bndel_periodic();
-    generalperbnd=1;
-    break;
+        case Bndel::periodic:
+          b=new Bndel_periodic( i );
+          break;
+        case Bndel::general_periodic:
+          t=Bndel::periodic;
+          b=new Bndel_periodic( i );
+          generalperbnd=1;
+          break;
         default:
-          b=new Bndel_triang(t);
-    break;
+          b=new Bndel_triang(i, t);
+          break;
       }
 
       b->read(in, v, nv) ;
@@ -196,23 +195,23 @@
 
       if (t==Bndel::periodic)
       {
-  if (generalperbnd) {
-    int pernb;
-    in >> pernb;
-          if (pernb<i) {
-      assert(perbnd_list[pernb].pernb==i);
-      ((Bndel_periodic*)b)->set_pnb(perbnd_list[pernb].b);
-      ((Bndel_periodic*)perbnd_list[pernb].b)->set_pnb(b);
-      perbnd_ok++;
-    }
-    else {
-      perbnd_list[i].b=b;
-      perbnd_list[i].pernb=pernb;
-      perbnd_card++;
-    }
-  }
+        if (generalperbnd) {
+          int pernb;
+          in >> pernb;
+                if (pernb<i) {
+            assert(perbnd_list[pernb].pernb==i);
+            ((Bndel_periodic*)b)->set_pnb(perbnd_list[pernb].b);
+            ((Bndel_periodic*)perbnd_list[pernb].b)->set_pnb(b);
+            perbnd_ok++;
+          }
+          else {
+            perbnd_list[i].b=b;
+            perbnd_list[i].pernb=pernb;
+            perbnd_card++;
+          }
+        }
         else if (fabs(b->vertex(0)->coord()[0]-b->vertex(1)->coord()[0])<EPS)
-  {
+        {
 
           double y0,y1;
           if (b->vertex(0)->coord()[1]<b->vertex(1)->coord()[1])
Index: alu2d/triang.cc
===================================================================
--- alu2d/triang.cc	(revision 1064)
+++ alu2d/triang.cc	(revision 1173)
@@ -293,735 +293,39 @@
   if( nconfDeg >= 0 ) {
     for( int i=0 ; i<connect.nf ; i++ )
       {
-	Bndel_triang *nb = nbbnd(i);
+  Bndel_triang *nb = nbbnd(i);
 
-	if (nb)
-	  {
-	    if (nb->type()==Bndel::periodic)
-	      {
-		Triang* tr = ((Bndel_periodic*)nb)->periodic_nb->nbel(0);
-		int dl = (tr->hashvtx(i) ? tr->connect.hvtx[i]->deepestLevel() : 0);
-		if( dl > nconfDeg )
-		  // if (((Bndel_periodic*)nb)->periodic_nb->deepestLevel() > nconfDeg)
-		  {
-		    result = true;
-		    break;
-		  }
-	      }
-	  }
-	else
-	  {
-	    int dl = (hashvtx(i) ? connect.hvtx[i]->deepestLevel() : 0);
-	    if( dl > nconfDeg )
-	      {
-		result = true;
-		break;
-	      }
-	  }
+  if (nb)
+    {
+      if (nb->type()==Bndel::periodic)
+        {
+    Triang* tr = ((Bndel_periodic*)nb)->periodic_nb->nbel(0);
+    int dl = (tr->hashvtx(i) ? tr->connect.hvtx[i]->deepestLevel() : 0);
+    if( dl > nconfDeg )
+      // if (((Bndel_periodic*)nb)->periodic_nb->deepestLevel() > nconfDeg)
+      {
+        result = true;
+        break;
       }
+        }
+    }
+  else
+    {
+      int dl = (hashvtx(i) ? connect.hvtx[i]->deepestLevel() : 0);
+      if( dl > nconfDeg )
+        {
+    result = true;
+    break;
+        }
+    }
+      }
   }
   return result;
 }
 
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::nbconnect(int fce, Thinelement * n, int b)  
-// #parameters:
-//   \ int           | fce | Lokale Kantennr. >=0
-//   \ Thinelement*  | n   | Pointer auf Nachbar 
-//   \ int           | b   | Lokale Nr. der gemeinsammen Kante auf dem Nachbarelement >=0
-// #description:
-//   Legt alle Nachbarschaftsinformationen auf der Kante mit der lokalen Nr. fce
-//   an.
-// #end(method)
-// ***************************************************
-/*
-  void Element::nbconnect(int fce, Thinelement * n, int b) { 
-  assert(0 <= fce) ;
-  fce %= connect.nf ;
-
-  connect.nb[fce] = n ; 
-  connect.bck[fce] = b ;
-  }
-  void Element::edgeconnect(int fce, Edge * n) { 
-  assert(0 <= fce) ;
-  fce %= connect.nf ;
-
-  connect.edge[fce] = n ; 
-  n->attach();
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::setnormdir(int fce, int dir)  
-// #parameters:
-//   \ int | fce | Lokale Kantennr. >= 0
-//   \ int | dor | Normalenrichtung (-1 oder 1)
-// #description:
-//   Legt die Richtung der gerichteten Normalen an der Kante mit der Nr. fce fest
-// #end(method)
-// ***************************************************
-/*void Element::setnormdir(int fce, int dir) {
-  assert( 0 <= fce );
-  fce %= connect.nf ;
-  assert( dir == 1 || dir == -1);
-  connect.normdir[fce] = dir;
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   Element::c::c()
-// #parameters:
-// #description:
-//   Konstruktor f"ur connect Daten (privat)
-// #end(method)
-// ***************************************************
-/*
-  Element::c::c() {
-  for( int i = 0 ; i < nv ; i ++ ) { vtx[i] = 0; hvtx[i] = 0; }
-  for( int j = 0 ; j < nf ; j ++ ) { nb[j] = 0 ; bck[j] = -1 ; normdir[j]=0 ; edge[j] = 0;}  
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   Element::c::~c()
-// #parameters:
-// #description:
-//   Destruktor f"ur connect Daten (privat)
-// #end(method)
-// ***************************************************
-/*
-  Element::c::~c() {
-  for(int i = 0 ; i < nv ; i ++ ) {
-  if(vtx[i]) vtx[i]->detach() ;
-  if(hvtx[i]) delete hvtx[i];
-  }
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::c::write(ofstream &out) const
-// #parameters:
-// #description:
-//   Ausschreiben der connect-Daten (privat)
-// #end(method)
-// ***************************************************
-/*
-  void Element::c::write(ofstream &out) const {
-  for(int i = 0 ; i < nv ; i ++ ) 
-  {
-  out << (vtx[i] ? vtx[i]->Listagent < Vertex > :: number() : -1 ) << "  " ;
-  //    out << bck[i] << "  " ;
-  //    out << nb[i] << "  :  ";
-  //    vtx[i]-> write(out);
-  }
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::c::read(ifstream & in, Vertex ** v, const int l) 
-// #parameters:
-//   Einlesen der connect-Daten (privat)
-// #description:
-// #end(method)
-// ***************************************************
-/*
-  void Element::c::read(ifstream & in, Vertex ** v, const int l) {
-  int c ;
-  for(int i = 0 ; i < nv ; i ++ ) {
-  in >> c ;
-  assert(-1 <= c && c < l) ;
-  if(c != -1) set((Vertex *)v[c], i) ;
-  }
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::outernormal(int fce,double (&n)[ncoord]) const
-// #parameters:
-//   \ int                 | fce | Lokale Kantennr.
-//   \ double (&)[ncoord]  | n   | R"uckgabe der Normalen
-// #description:
-//   Liefert unskalierte "au"sere Normale in n zur"uck
-// #end(method)
-// ***************************************************
-/*
-  void Element::outernormal(int fce,double (&n)[ncoord]) const
-  {
-  n[0]= _outernormal[fce%connect.nf][0];
-  n[1]= _outernormal[fce%connect.nf][1];
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::dirnormal(int fce,double (&n)[ncoord]) const
-// #parameters:
-//   \ int                 | fce | Lokale Kantennr.
-//   \ double (&)[ncoord]  | n   | R"uckgabe der Normalen 
-// #description:
-//   Liefert unskalierte gerichtete Normale in n zur"uck
-// #end(method)
-// ***************************************************
-/*
-  void Element::dirnormal(int fce,double (&n)[ncoord]) const
-  {
-  outernormal(fce,n);
-  for (int i=0;i<ncoord;i++)
-  n[i]*=normaldir(fce);
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::tolocal(const double (&v)[ncoord], double (&bary)[3]) const
-// #parameters:
-//   \ double (&)[ncoord]  | v    | globale Koordinaten
-//   \ double (&)[3]       | bary | baryzentrische Koordinaten
-// #description:
-//   Rechnet globale (x,y)-Koordinaten in baryzentrische
-//   Koordinaten bez"uglich des Dreiecks um. Bezeichnen
-//   v0,v1 und v2 die Koordinaten der Eckpunkte, so
-//   gilt wegen l0 + l1 + l2 = 1:
-//
-//           l0 v0 + l1 v1 + l2 v2 = v
-//
-//     <==>  l0 (v0-v0) + l1 (v1-v0) + l2 (v2-v0) = v-v0
-//
-//     <==>  l1 (v1-v0) + l2 (v2-v0) = v-v0
-//
-//             (a  b) (l1)   (e)
-//     <==>:   (    ) (  ) = ( )
-//             (c  d) (l2)   (f)
-//
-//
-//             (l1)     1   ( d  -b) (e)
-//     <==>    (  ) = ----- (      ) ( )
-//             (l2)   ad-bc (-c   a) (f)
-// #end(method)
-// ***************************************************
-/*
-  void Element::tolocal(const double (&v)[ncoord], double (&bary)[3]) const
-  {
-  const double (&v0)[ncoord]=connect.vtx[0]->coord();
-  const double (&v1)[ncoord]=connect.vtx[1]->coord();
-  const double (&v2)[ncoord]=connect.vtx[2]->coord();
-  double a   = v1[0] - v0[0];
-  double b   = v2[0] - v0[0];
-  double c   = v1[1] - v0[1];
-  double d   = v2[1] - v0[1];
-  double e   =  v[0] - v0[0];
-  double f   =  v[1] - v0[1];
-  double det = a * d - b * c;
-
-  assert(ncoord == 2);
-  assert(fabs(det) > EPS);
-
-  bary[1] = (d * e - b * f) / det;
-  bary[2] = (a * f - c * e) / det;
-  bary[0] = 1.0 - bary[1] - bary[2];
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::fromlocal(const double (&bary)[3],double (&v)[ncoord]) const
-// #parameters:
-//   \ const double (&)[3] | bary | baryzentrische Koordinaten
-//   \ double (&)[ncoord]  | v    | globale Koordinaten
-// #description:
-//   Rechnet die baryzentrischen Koordinaten bez"uglich des Dreiecks
-//   in globale (x,y)-Koordinaten um
-// #end(method)
-// ***************************************************
-/*
-  void Element::fromlocal(const double (&bary)[3],double (&v)[ncoord]) const
-  {
-  const double (&v0)[ncoord]=connect.vtx[0]->coord();
-  const double (&v1)[ncoord]=connect.vtx[1]->coord();
-  const double (&v2)[ncoord]=connect.vtx[2]->coord();
-
-  for (int i=0;i<ncoord;i++)
-  v[i]=bary[0]*v0[i]+
-  bary[1]*v1[i]+
-  bary[2]*v2[i];  
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::midpoint(int fce, double (&bary)[3]) const
-// #parameters:
-//   \ int            | fce  | Nummer der Kante
-//   \ double (&)[3]  | bary | baryzentrische Koordinaten
-// #description:
-//   Berechnet den Mittelpunkt der Seite fce
-//   in baryzentrischen Koordinaten
-// #end(method)
-// ***************************************************
-/*
-  void Element::midpoint(int fce, double (&bary)[3]) const
-  {
-  for (int i=0;i<3;i++)
-  bary[i]=((i==fce%3) ? 0.0 : 0.5);
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::facepoint(int fce, double pos, double (&bary)[3]) const
-// #parameters:
-//   \ int           | fce  | Nummer der Kante
-//   \ double        | pos  | Position auf der Kante
-//   \ double (&)[3] | bary | baryzentrische Koordinaten
-// #description:
-//   Verl"auft die Seite fce von P0 nach P1, so
-//   gilt bary = P0 + pos * (P1 - P0).
-// #end(method)
-// ***************************************************
-/*
-  void Element::facepoint(int fce, double pos, double (&bary)[3]) const
-  {
-  bary[fce%3] = 0.0;
-
-  if (normaldir(fce) == 1)
-  {
-  bary[(fce+1)%3] = 1.0 - pos;
-  bary[(fce+2)%3] = pos;
-  }
-  else
-  {
-  bary[(fce+1)%3] = pos;
-  bary[(fce+2)%3] = 1.0 - pos;
-  }
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   int Element::isecpoint(int fce, const double (&p)[ncoord],
-//                          double (&bary)[3]) const
-// #parameters:
-//   \ int                     | fce  | Nummer der Kante
-//   \ const double(&)[ncoord] | p    | Punktkoordinaten
-//   \ double (&)[3]           | bary | baryzentrische Koordinaten
-//                                      des Schnittpunktes
-// #description:
-//   Berechnet den Schnittpunkt der Verbindungsgeraden
-//   des Elementschwerpunktes mit dem Punkt p
-//   und der Kante fce. Existiert ein Schnittpunkt,
-//   so wird 1 zur"uckgegeben, ansonsten 0. 
-// #end(method)
-// ***************************************************
-/*
-  int Element::isecpoint(int fce, const double (&pa)[ncoord],
-  double (&bary)[3]) const
-  {
-  int ret = 1;
-  double bary_cog[3] = {1.0/3.0, 1.0/3.0, 1.0/3.0};
-  double v[ncoord],cog[2],pb[2],pc[2],pd[2],det,s;
-
-  assert(ncoord == 2);
-
-  fromlocal(bary_cog,cog);
-  pb[0] = cog[0] - pa[0];
-  pb[1] = cog[1] - pa[1];
-  pc[0] = vertex(fce+1)->coord()[0];
-  pc[1] = vertex(fce+1)->coord()[1];
-  pd[0] = vertex(fce+2)->coord()[0] - pc[0];
-  pd[1] = vertex(fce+2)->coord()[1] - pc[1];
-
-  det = pb[1] * pd[0] - pb[0] * pd[1];
-
-  if (fabs(det) <= EPS)
-  {
-  ret = 0;
-  }
-  else
-  {
-  s = (pd[0] * (pc[1] - pa[1]) - pd[1] * (pc[0] - pa[0])) / det;
-
-  v[0] = pa[0] + s * pb[0];
-  v[1] = pa[1] + s * pb[1];
-  tolocal(v,bary);
-  }
-
-  return ret;
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   int Element::isecpoint(int fce, const double (&p)[ncoord],
-//                          double (&bary)[3]) const
-// #parameters:
-//   \ int                     | fce  | Nummer der Kante
-//   \ const double(&)[ncoord] | p    | Punktkoordinaten
-//   \ double (&)[ncoord]      | pret | Koordinaten
-//                                      des Schnittpunktes
-// #description:
-//   Berechnet den Schnittpunkt der Verbindungsgeraden
-//   des Elementschwerpunktes mit dem Punkt p
-//   und der Kante fce. Existiert ein Schnittpunkt,
-//   so wird 1 zur"uckgegeben, ansonsten 0. 
-// #end(method)
-// ***************************************************
-/*
-  int Element::isecpoint(int fce, const double (&pa)[ncoord],
-  double (&pret)[ncoord]) const
-  {
-  int ret = 1;
-  double bary_cog[3] = {1.0/3.0, 1.0/3.0, 1.0/3.0};
-  double cog[2],pb[2],pc[2],pd[2],det,s;
-
-  assert(ncoord == 2);
-
-  fromlocal(bary_cog,cog);
-  pb[0] = cog[0] - pa[0];
-  pb[1] = cog[1] - pa[1];
-  pc[0] = vertex(fce+1)->coord()[0];
-  pc[1] = vertex(fce+1)->coord()[1];
-  pd[0] = vertex(fce+2)->coord()[0] - pc[0];
-  pd[1] = vertex(fce+2)->coord()[1] - pc[1];
-
-  det = pb[1] * pd[0] - pb[0] * pd[1];
-
-  if (fabs(det) <= EPS)
-  {
-  ret = 0;
-  }
-  else
-  {
-  s = (pd[0] * (pc[1] - pa[1]) - pd[1] * (pc[0] - pa[0])) / det;
-
-  pret[0] = pa[0] + s * pb[0];
-  pret[1] = pa[1] + s * pb[1];
-  }
-
-  return ret;
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   int Element::inside(Vertex &v) const
-// #parameters:
-// #description:
-//   Liefert 0 zur"uck falls v au"serhalb des Dreiecks,
-//   1 falls innerhalb und -1 falls v auf einer Kante liegt
-// #end(method)
-// ***************************************************
-/*
-  int Element::inside(Vertex &v) const
-  {
-  double n[ncoord];
-  double wert,test=0.0;
-  int ret=1;
-  for (int i=0;i<connect.nf;i++)
-  {
-  outernormal(i,n);
-  wert=   n[0]*(v.coord()[0]-vertex(i+1)->coord()[0])
-  + n[1]*(v.coord()[1]-vertex(i+1)->coord()[1]);
-  if (wert==0.0)
-  {
-  ret=-1;
-  continue;
-  }
-  if (test==0.0)
-  test=wert;
-  else
-  if (wert*test<0)
-  {
-  ret=0;
-  break;
-  }
-  }
-  return ret;  
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   int Element::getAllNb(Vtx_btree* vtx, vector<Thinelement *> vec) const
-// #parameters: 
-// #description:
-//   will return all neighbours associated with the element in a vector
-// #end(method)
-// ***************************************************
-/*
-  void Element::getAllNb(Vtx_btree::Node* node, stack<Thinelement *> vec) 
-  {
-  if(!node->leftNode())
-  vec.push(node->leftElement());
-  else {
-  getAllNb(node->leftNode(), vec);
-  }
-  if(!node->rightNode())
-  vec.push(node->rightElement());
-  else {
-  getAllNb(node->rightNode(), vec);
-  }    
-  //if(!vtx->right())
-  //  vec.push_back(vtx->getrnb());
-  //else {    
-  //  getAllNb(vtx->right(), vec);        
-  //}
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   int Element::inside(const double (&)[2]) const
-// #parameters:
-//   \ const double (&)[2] | point | Punktkoordinaten
-// #description:
-//   Liefert 1 zur"uck, falls point innerhalb des
-//   Dreiecks liegt, 0 sonst.
-// #end(method)
-// ***************************************************
-/*
-  int Element::inside(const double (&point)[2]) const
-  {
-  int i,ret = 1;
-  double bary[3];
-
-  tolocal(point,bary);
-
-  for (i=0;i<3;i++)
-  if ((bary[i] < -EPS) || (bary[i] > 1.0 + EPS))
-  ret = 0;
-
-  return ret;
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::setrefine(int fce) 
-// #parameters:
-//   \ int | fce | Lokale Kantennr.
-// #description:
-//   Macht die Kante mit der lokalen Nr. fce zur Verfeinerungskante
-// #end(method)
-// ***************************************************
-/*
-  void Element::setrefine(int fce) 
-  {
-  assert( 0<=fce );
-  fce%=connect.nv;
-  Vertex *tmp_v[3]={connect.vtx[0],connect.vtx[1],connect.vtx[2]};
-  Thinelement *tmp_n[3]={connect.nb[0],connect.nb[1],connect.nb[2]};
-  Edge *tmp_e[3]={connect.edge[0],connect.edge[1],connect.edge[2]};
-  Vtx_btree* tmp_btree[3] = {connect.hvtx[0], connect.hvtx[1], connect.hvtx[2] };
-  short int tmp_b[3]={connect.bck[0],connect.bck[1],connect.bck[2]};
-  short int tmp_no[3]={connect.normdir[0],connect.normdir[1],connect.normdir[2]};
-  double tmp_sln[3]={_sidelength[0],_sidelength[1],_sidelength[2]};
-  double tmp_onx[3]={_outernormal[0][0],_outernormal[1][0],_outernormal[2][0]};
-  double tmp_ony[3]={_outernormal[0][1],_outernormal[1][1],_outernormal[2][1]};
-  for (int j=0;j<connect.nv;j++)
-  {  
-  connect.vtx[j]=tmp_v[(fce+j)%connect.nv];  
-  connect.bck[j]=tmp_b[(fce+j)%connect.nv];  
-  connect.nb[j]=tmp_n[(fce+j)%connect.nv];  
-  connect.edge[j]=tmp_e[(fce+j)%connect.nv];  
-  connect.normdir[j]=tmp_no[(fce+j)%connect.nv];  
-  connect.nb[j]->nbconnect(connect.bck[j],this,j);
-  connect.hvtx[j] = tmp_btree[(fce+j)%connect.nv];
-
-  _sidelength[j]     = tmp_sln[(fce+j)%connect.nv];
-  _outernormal[j][0] = tmp_onx[(fce+j)%connect.nv];
-  _outernormal[j][1] = tmp_ony[(fce+j)%connect.nv];
-  }
-  }
-*/
-// ***************************************************
-// #begin(method)
-// #method:
-//   void Element::init()
-// #parameters:
-// #description:
-//   Initialisierung der Instanzvariablen
-// #end(method)
-// ***************************************************
-/*
-  void Element::init()
-  {
-  // calculate area 
-
-  const double (&vc0)[ncoord]=connect.vtx[0]->coord();
-  const double (&vc1)[ncoord]=connect.vtx[1]->coord();
-  const double (&vc2)[ncoord]=connect.vtx[2]->coord();
-
-  _area =  fabs(0.5 * (  (vc0[0]-vc1[0])*(vc0[1]+vc1[1])
-  + (vc1[0]-vc2[0])*(vc1[1]+vc2[1])
-  + (vc2[0]-vc0[0])*(vc2[1]+vc0[1])) );
-
-  assert(_area > 0.0);
-
-  //calculate outer normal and sidelength
-
-  int i;
-
-  for (i=0;i<3;i++)
-  {
-  _outernormal[i][0]= (vertex(i+2)->coord()[1]-vertex(i+1)->coord()[1]);
-  _outernormal[i][1]=-(vertex(i+2)->coord()[0]-vertex(i+1)->coord()[0]);
-
-  _sidelength[i] = sqrt(  _outernormal[i][0]*_outernormal[i][0]
-  + _outernormal[i][1]*_outernormal[i][1]);
-  }
-
-  // calculate minheight
-
-  double maxlen = _sidelength[0];
-  for (i=1;i<3;i++)
-  maxlen = ((_sidelength[i] > maxlen) ? _sidelength[i] : maxlen);
-  assert(maxlen > 0.0);
-
-  _minheight = 2.0 * _area / maxlen;
-
-  }
-*/
-
-// ***************************************************
-// #begin(method)
-// #method:
-//   int Element::setrefine()
-// #parameters:
-// #description:
-//   Macht die l"angste Kante zur Verfeinerungskante und 
-//   gibt 0 zur"uck falls eine umsortierung n"otig war
-//   1 sonst
-// #end(method)
-// ***************************************************
-/*
-  int Element::setrefine()
-  {
-  double maxkantenlen=-1.0,kantenlen;
-  int maxkante=-1;
-  
-  for (int i=0;i<connect.nf;i++)
-  {
-  kantenlen=sidelength(i);
-  if (kantenlen > maxkantenlen)
-  {
-  maxkantenlen=kantenlen;
-  maxkante=i;
-  } 
-  }
-  if (maxkante>0)
-  setrefine(maxkante);
-  return maxkante==0;
-  }
-*/
-
-/****************************************************
- // #begin(method)
- // #method:
- //   int Element::setorientation()
- // #parameters:
- // #description:\
- //   Sorgt da"ur das das Dreieck gegen den Uhrzeigersinn orientiert wird
-//   (wichtig z.B. f"ur outernormal). Liefert 0 zur"uck falls die Orientierung
-//   vorher im Uhrzeigersinn war, 1 falls keine Umsortierung der Punkte
-//   n"otig war. L"a"st die Verfeinerungskante umber"uhrt 
-// #end(method)
-***************************************************/
-/*
-  int Element::setorientation()
-  {
-  double o;
-  const double (&v0)[ncoord]=connect.vtx[0]->coord();
-  const double (&v1)[ncoord]=connect.vtx[1]->coord();
-  const double (&v2)[ncoord]=connect.vtx[2]->coord();
-  o=(v1[0]-v0[0])*(v2[1]-v1[1])-(v1[1]-v0[1])*(v2[0]-v1[0]);
-  if (fabs(o)<1e-10) {
-  cerr << o << " " 
-  << v0[0] << "," << v0[1] << " "
-  << v1[0] << "," << v1[1] << " "
-  << v2[0] << "," << v2[1] << endl;
-  }
-  assert(o);  // Entartet!
-  if (o<0)    // Orientierung im Uhrzeigersinn!
-  {
-  cerr << "Orienting" << endl;
-  Vertex *tmpv=connect.vtx[1];
-  Thinelement *tmpn=connect.nb[1];
-  Edge *tmpe=connect.edge[1];
-  short int tmpb=connect.bck[1];
-  short int tmpd=connect.normdir[1];
-  double tmponx=_outernormal[1][0];
-  double tmpony=_outernormal[1][1];
-  double tmpsln=_sidelength[1];
-
-  connect.vtx[1]=connect.vtx[2];
-  connect.nb[1]=connect.nb[2];
-  connect.edge[1]=connect.edge[2];
-  connect.bck[1]=connect.bck[2];
-  connect.normdir[1]=connect.normdir[2];
-  connect.nb[1]->nbconnect(connect.bck[1],this,1);
-  connect.vtx[2]=tmpv;
-  connect.nb[2]=tmpn;
-  connect.edge[2]=tmpe;
-  connect.bck[2]=tmpb;
-  connect.normdir[2]=tmpd;
-  connect.nb[2]->nbconnect(connect.bck[2],this,2);
-
-  _outernormal[1][0] = _outernormal[2][0];
-  _outernormal[1][1] = _outernormal[2][1];
-  _sidelength[1]     = _sidelength[2];
-  _outernormal[2][0] = tmponx;
-  _outernormal[2][1] = tmpony;
-  _sidelength[2]     = tmpsln;
-  }
-  return (o>0);
-  }
-*/
-
 /***************************************************
  // #begin(method)
  // #method:
- //   void Element::addhvtx(Vertex* invtx, int fce)
- // #parameters:
- //   \ Vertex* | invtx | Knoten
- //   \ int     | fce   | lokale Kantennummer
- // #description:\
- //   Fuegt den uebergebenen Knoten als haengenden Knoten
- //   in das Empfaengerelement auf der Seite fce ein.
- // #end(method)
- ***************************************************/
-/*
-  void Element::addhvtx(Vertex* invtx, Thinelement *lnb,Thinelement *rnb,int fce)
-  {
-  if( invtx ) {
-  assert(rnb);
-  assert(lnb);
-  if( !connect.hvtx[fce] )
-  connect.hvtx[fce] = new Vtx_btree(connect.vtx[(fce+1)%connect.nf],lnb,rnb);
-  connect.hvtx[fce]->insert(invtx,lnb,rnb);
-  } else {
-  assert(!connect.hvtx[fce]); 
-  }
-  }
-*/
-
-/***************************************************
- // #begin(method)
- // #method:
  //   void Triang::newNeighbour(Triang* nb, int fce, int nbfce, splitrule_t sr, bool setnormal)
  // #parameters:
  //   \ Triang*     | nb        | neues Nachbardreieck
@@ -1085,23 +389,24 @@
 
 int Triang::split(void * (&e)[nparts], Listagency < Vertex > * agnc,
                   Multivertexadapter & mva, 
-		  nconf_vtx_t *ncv,
-		  splitrule_t sr,
-		  int nconfDeg,Refco::tag_t default_ref,
-		  Prolong_basic *pro_el)
+                  nconf_vtx_t *ncv,
+                  splitrule_t sr,
+                  int nconfDeg,
+                  Refco::tag_t default_ref,
+                  Prolong_basic *pro_el)
 {
   int ret = 0;
 
   assert(splitrule() == unsplit);
 
   switch (sr)
-    {
+  {
     case triang_conf2:
       {
         Triang* t1;
         Triang* t2;
-	Edge *newedge[3];
-	newedge[2]=new Edge(hdl);
+        Edge *newedge[3];
+        newedge[2]=new Edge(hdl);
 
         mysplit = triang_conf2;
 
@@ -1115,24 +420,25 @@
           agnc->insert(nv = new Fullvertex(p,level()));
           t1 = new Triang(nv, connect.vtx[0], connect.vtx[1]);
           t2 = new Triang(nv, connect.vtx[2], connect.vtx[0]);
-	  t1->sethdl(hdl);
-	  t2->sethdl(hdl);
+          t1->sethdl(hdl);
+          t2->sethdl(hdl);
           t1->connect.hvtx[0] = connect.hvtx[2];
           t2->connect.hvtx[0] = connect.hvtx[1];
           connect.hvtx[1] = connect.hvtx[2] = NULL;
-	  newedge[0]=new Edge(hdl);
-	  newedge[1]=new Edge(hdl);
-	  
+          newedge[0]=new Edge(hdl);
+          newedge[1]=new Edge(hdl);
+    
           // Nachbarschaftsinfo der Nachbarn "uber die Kanten
-	  // 1 und 2 neu setzen (aber nur, falls die Nachbarn nicht
+          // 1 und 2 neu setzen (aber nur, falls die Nachbarn nicht
           // gr"ober sind als Empfaengerelement)
           if( neighbour(1)->thinis(element_like) ) {
             if( !(((Element*)neighbour(1))->hashvtx(opposite(1))) )
               ((Triang*)neighbour(1))->newNeighbour(t2, opposite(1), 0,
                                                     triang_conf2);
-	    else
-	      nbel(1)->connect.hvtx[opposite(1)]->head->rnb = t2;
-          } else {
+            else
+              nbel(1)->connect.hvtx[opposite(1)]->head->rnb = t2;
+          } 
+          else {
             neighbour(1)->nbconnect(0, t2, 0);
           }
 
@@ -1140,12 +446,13 @@
             if( !(((Element*)neighbour(2))->hashvtx(opposite(2))) )
               ((Triang*)neighbour(2))->newNeighbour(t1, opposite(2),
                                                     0, triang_conf2);
-	    else
-	      nbel(2)->connect.hvtx[opposite(2)]->head->rnb = t1;
-          } else {
+            else
+              nbel(2)->connect.hvtx[opposite(2)]->head->rnb = t1;
+          } 
+          else {
             neighbour(2)->nbconnect(0, t1, 0);
           }
-	
+  
           // Nachbarschaft der neu entstandenen Elemente t1 und t2 regeln
           t1->nbconnect(0, connect.nb[2], connect.bck[2]);
           t1->nbconnect(2, t2, 1);
@@ -1159,18 +466,19 @@
           t2->setnormdir(0, connect.normdir[1]);
           t2->setnormdir(1, -1);
           t2->setnormdir(2, connect.normdir[0]);
-	  t1->edgeconnect(0,connect.edge[2]);
-	  t1->edgeconnect(1,newedge[0]);
-	  t1->edgeconnect(2,newedge[2]);
-	  t2->edgeconnect(0,connect.edge[1]);
-	  t2->edgeconnect(1,newedge[2]);
-	  t2->edgeconnect(2,newedge[1]);
+          t1->edgeconnect(0,connect.edge[2]);
+          t1->edgeconnect(1,newedge[0]);
+          t1->edgeconnect(2,newedge[2]);
+          t2->edgeconnect(0,connect.edge[1]);
+          t2->edgeconnect(1,newedge[2]);
+          t2->edgeconnect(2,newedge[1]);
 
           // Nachbarelement (=Randelement) verfeinern
           ncv = new nconf_vtx_t(nv, t1, t2);
           Hier<Bndel>* n = (Hier<Bndel>*)connect.nb[0];
           n->refine_leaf(agnc, &mva,ncv,nconfDeg,default_ref,pro_el);
-        } else {
+        } 
+        else {
           // Verfeinerungsnachbar ist "normales" Element
           Vertex* nv;
           double b[3],p[2];
@@ -1182,23 +490,24 @@
           if( connect.hvtx[0] ) {
             nv = connect.hvtx[0]->getHead();
             usehvtx = true;
-	    Hier<Element> *tr;
-	    tr = ((Hier<Element>*)neighbour(0))->down()->next();
-	    if (tr->leaf()) 
-	      newedge[0]=connect.hvtx[0]->getrnb()->edge(2);
-	    else
-	      newedge[0]=connect.hvtx[0]->getrnb()->edge(0);
-	    tr = ((Hier<Element>*)neighbour(0))->down();
-	    if (tr->leaf()) 
-	      newedge[1]=connect.hvtx[0]->getlnb()->edge(1);	  
-	    else
-	      newedge[1]=connect.hvtx[0]->getlnb()->edge(0);
-          } else {
+            Hier<Element> *tr;
+            tr = ((Hier<Element>*)neighbour(0))->down()->next();
+            if (tr->leaf()) 
+              newedge[0]=connect.hvtx[0]->getrnb()->edge(2);
+            else
+              newedge[0]=connect.hvtx[0]->getrnb()->edge(0);
+            tr = ((Hier<Element>*)neighbour(0))->down();
+            if (tr->leaf()) 
+              newedge[1]=connect.hvtx[0]->getlnb()->edge(1);    
+            else
+              newedge[1]=connect.hvtx[0]->getlnb()->edge(0);
+          } 
+          else {
             midpoint(0, b);
             fromlocal(b,p);
             agnc->insert(nv = new Fullvertex(p,level()));
-	    newedge[0]=new Edge(hdl);
-	    newedge[1]=new Edge(hdl);
+            newedge[0]=new Edge(hdl);
+            newedge[1]=new Edge(hdl);
           }
 
           // Neue Elemente erzeugen
@@ -1211,11 +520,11 @@
             tr = (Triang*)(tr->down()->next());
             if( tr->leaf() ) {
               t1->nbconnect(1, tr, 2);
-	      assert(connect.hvtx[0]->getrnb()==tr);
+        assert(connect.hvtx[0]->getrnb()==tr);
             } else {
               tr = (Triang*)(tr->down());
               t1->nbconnect(1, tr, 0);
-	      assert(connect.hvtx[0]->getrnb()==tr);
+        assert(connect.hvtx[0]->getrnb()==tr);
             }
           } else {
             t1->nbconnect(1, neighbour(0), opposite(0));
@@ -1230,11 +539,11 @@
             tr = (Triang*)(tr->down());
             if( tr->leaf() ) {
               t2->nbconnect(2, tr, 1);
-	      assert(connect.hvtx[0]->getlnb()==tr);
+        assert(connect.hvtx[0]->getlnb()==tr);
             } else {
               tr = (Triang*)(tr->down()->next());
               t2->nbconnect(2, tr, 0);
-	      assert(connect.hvtx[0]->getlnb()==tr);
+        assert(connect.hvtx[0]->getlnb()==tr);
             }
           } else {
             t2->nbconnect(2, neighbour(0), opposite(0));
@@ -1270,8 +579,8 @@
               ((Triang*)neighbour(1))->newNeighbour(t2, opposite(1), 0,
                                                     triang_conf2);
             } else {
-	      nbel(1)->connect.hvtx[opposite(1)]->head->lnb = t2;
-	    }
+        nbel(1)->connect.hvtx[opposite(1)]->head->lnb = t2;
+      }
           } else {
             neighbour(1)->nbconnect(0, t2, 0);
           }
@@ -1280,9 +589,9 @@
             if( !(((Triang*)neighbour(2))->hashvtx(opposite(2))) ) {
               ((Triang*)neighbour(2))->newNeighbour(t1, opposite(2), 0,
                                                     triang_conf2);
-	    } else {
-	      nbel(2)->connect.hvtx[opposite(2)]->head->rnb = t1;
-	    }
+      } else {
+        nbel(2)->connect.hvtx[opposite(2)]->head->rnb = t1;
+      }
           } else {
             neighbour(2)->nbconnect(0, t1, 0);
           }
@@ -1301,266 +610,233 @@
           }
           t1->setnormdir(0, normaldir(2));
           t2->setnormdir(0, normaldir(1));
-	  t1->sethdl(hdl);
-	  t2->sethdl(hdl);
-	  t1->edgeconnect(0,connect.edge[2]);
-	  t1->edgeconnect(1,newedge[0]);
-	  t1->edgeconnect(2,newedge[2]);
-	  t2->edgeconnect(0,connect.edge[1]);
-	  t2->edgeconnect(1,newedge[2]);
-	  t2->edgeconnect(2,newedge[1]);
+    t1->sethdl(hdl);
+    t2->sethdl(hdl);
+    t1->edgeconnect(0,connect.edge[2]);
+    t1->edgeconnect(1,newedge[0]);
+    t1->edgeconnect(2,newedge[2]);
+    t2->edgeconnect(0,connect.edge[1]);
+    t2->edgeconnect(1,newedge[2]);
+    t2->edgeconnect(2,newedge[1]);
         }
-	if (this->is(Refco::ref_2)) {
-	  t1->mark(Refco::ref_1);
-	  t2->mark(Refco::ref_1);
-	}
+
+        if (this->is(Refco::ref_2)) 
+        {
+          t1->mark(Refco::ref_1);
+          t2->mark(Refco::ref_1);
+        }
+
         e[0] = t1;
         e[1] = t2;
-	/*
-	  if (pro_el)
-	  pro_el->operator()(this, (Element**)e, 2);
-	*/
         ret = 2;
       }
       break;
     case triang_quarter:
       {
-	// Every triangle is split into four triangles #0, #1, #2,
-	// and #3. Three new vertices (0), (1), and (2) are created.
-	// If the edge 1->2 is the longest edge and the orientation
-	// is correct, then the same holds for the four children.
-	// Thus no additional calls to setrefine() or setorientation()
-	// are required. Note that this splitrule is only intended for
-	// the global refinements performed at the beginning of a
-	// simulation. Coarsening of triangles created using
-	// ``triang_quarter'' is not possible and thus prohibited by
-	// Triang::canCoarsen() below!
-	//
-	//                 1*                        1* 
-	//                 /|                        /| 
-	//                / |                       /1| 
-	//               /  |                      /  | 
-	//              /   |                     /   | 
-	//             /    |                    / #1 |
-	//            /     |                   /     | 
-	//           /      |                  /2    0| 
-	//          /       |              (0)*-------*(2)
-	//         /        |     ==>        /|0    2/| 
-	//        /         |               /1|     /1| 
-	//       /          |              /  | #3 /  | 
-	//      /           |             /   |   /   | 
-	//     /            |            / #2 |  / #0 | 
-	//    /             |           /     |1/     | 
-	//   /              |          /2    0|/2    0| 
-	// 2*---------------*0       2*-------*-------*0
+  // Every triangle is split into four triangles #0, #1, #2,
+  // and #3. Three new vertices (0), (1), and (2) are created.
+  // If the edge 1->2 is the longest edge and the orientation
+  // is correct, then the same holds for the four children.
+  // Thus no additional calls to setrefine() or setorientation()
+  // are required. Note that this splitrule is only intended for
+  // the global refinements performed at the beginning of a
+  // simulation. Coarsening of triangles created using
+  // ``triang_quarter'' is not possible and thus prohibited by
+  // Triang::canCoarsen() below!
+  //
+  //                 1*                        1* 
+  //                 /|                        /| 
+  //                / |                       /1| 
+  //               /  |                      /  | 
+  //              /   |                     /   | 
+  //             /    |                    / #1 |
+  //            /     |                   /     | 
+  //           /      |                  /2    0| 
+  //          /       |              (0)*-------*(2)
+  //         /        |     ==>        /|0    2/| 
+  //        /         |               /1|     /1| 
+  //       /          |              /  | #3 /  | 
+  //      /           |             /   |   /   | 
+  //     /            |            / #2 |  / #0 | 
+  //    /             |           /     |1/     | 
+  //   /              |          /2    0|/2    0| 
+  // 2*---------------*0       2*-------*-------*0
         //                                   (1)
 
-	if (0) {
-	  //Xdisplay disp(g_argc,g_argv,"a","Grid",
-	  //		      350.,450.,450.);
-	  double p1[2],p2[2];
-	  double bary[3]={1./3.,1./3.,1./3.};
-#ifdef USE_ALUGRID_XDISPLAY
-	  mesh->draw(disp);
-#endif
-	  {
-	    this->fromlocal(bary,p1);
-	    this->fromlocal(bary,p2);
-	    p1[0]-=0.05;
-	    p1[1]-=0.05;
-	    p2[0]+=0.05;
-	    p2[1]+=0.05;
-	    Fullvertex pp1(p1,-1);
-	    Fullvertex pp2(p2,-1);
-	    //disp.linedraw(&pp1,&pp2,disp.bcol[17]);
-	  }
-	  {
-	    this->fromlocal(bary,p1);
-	    this->fromlocal(bary,p2);
-	    p1[0]-=0.05;
-	    p1[1]+=0.05;
-	    p2[0]+=0.05;
-	    p2[1]-=0.05;
-	    Fullvertex pp1(p1,-1);
-	    Fullvertex pp2(p2,-1);
-	    //disp.linedraw(&pp1,&pp2,disp.bcol[17]);
-	  }
-	}
-        Triang *newtr[4];
-        Vertex *newvtx[3];
-	Edge *newedge[9];
-        bool usehvtx[3];
-        int i;
+    Triang *newtr[4];
+    Vertex *newvtx[3];
+    Edge *newedge[9];
+    bool usehvtx[3];
+    int i;
 
-        mysplit = triang_quarter;
+    mysplit = triang_quarter;
 
-        // create new vertices
-        for (i=0;i<3;i++)
-	  {
-	    double b[3],p[2];
+    // create new vertices
+    for (i=0;i<3;i++)
+    {
+      double b[3],p[2];
 
-	    usehvtx[i] = false;
-	    if (connect.nb[i]->thinis(bndel_like))
-	      {
-		assert(!connect.hvtx[i]);
-		((Bndel*)connect.nb[i])->get_splitpoint(p);
-		newvtx[i] = new Fullvertex(p,level());
-		agnc->insert(newvtx[i]);
-		newedge[2*i]=new Edge(hdl);
-		newedge[2*i+1]=new Edge(hdl);
-	      }
-	    else
-	      {
-		// Use hanging node if it exists. Otherwise create
-		// new vertex and insert it as hanging node in the
-		// corresponding neighbour.
+      usehvtx[i] = false;
+      if (connect.nb[i]->thinis(bndel_like))
+      {
+        assert(!connect.hvtx[i]);
+        ((Bndel*)connect.nb[i])->get_splitpoint(p);
+        newvtx[i] = new Fullvertex(p,level());
+        agnc->insert(newvtx[i]);
+        newedge[2*i]=new Edge(hdl);
+        newedge[2*i+1]=new Edge(hdl);
+      }
+      else
+      {
+        // Use hanging node if it exists. Otherwise create
+        // new vertex and insert it as hanging node in the
+        // corresponding neighbour.
 
-		if(connect.hvtx[i])
-		  {
-		    usehvtx[i] = true;
-		    newvtx[i]  = connect.hvtx[i]->getHead();
-		    newedge[2*i]=connect.hvtx[i]->getrnb()->edge(opposite(i));
-		    newedge[2*i+1]=connect.hvtx[i]->getlnb()->edge(opposite(i));
-		  }
-		else
-		  {
-		    midpoint(i,b);
-		    fromlocal(b,p);
-		    newvtx[i] = new Fullvertex(p,level());
-		    agnc->insert(newvtx[i]);
-		    newedge[2*i]=new Edge(hdl);
-		    newedge[2*i+1]=new Edge(hdl);
-		  }
-	      }
-	    newedge[6+i]=new Edge(hdl);
-	  }
+        if(connect.hvtx[i])
+        {
+          usehvtx[i] = true;
+          newvtx[i]  = connect.hvtx[i]->getHead();
+          newedge[2*i]=connect.hvtx[i]->getrnb()->edge(opposite(i));
+          newedge[2*i+1]=connect.hvtx[i]->getlnb()->edge(opposite(i));
+        }
+        else
+        {
+          midpoint(i,b);
+          fromlocal(b,p);
+          newvtx[i] = new Fullvertex(p,level());
+          agnc->insert(newvtx[i]);
+          newedge[2*i]=new Edge(hdl);
+          newedge[2*i+1]=new Edge(hdl);
+        }
+      }
+      newedge[6+i]=new Edge(hdl);
+    }
 
-        // create new elements
+    // create new elements
+    newtr[0] = new Triang(connect.vtx[0],newvtx[2],newvtx[1]);
+    newtr[1] = new Triang(newvtx[2],connect.vtx[1],newvtx[0]);
+    newtr[2] = new Triang(newvtx[1],newvtx[0],connect.vtx[2]);
+    newtr[3] = new Triang(newvtx[0],newvtx[1],newvtx[2]);
+    for (i=0;i<4;i++) {
+      newtr[i]->sethdl(hdl);
+      e[i] = newtr[i];
+    }
+    for (i=0;i<3;i++) {
+      newtr[i]->edgeconnect(i,newedge[6+i]);
+      newtr[i]->edgeconnect(i+1,newedge[2*((i+1)%3)+1]);
+      newtr[i]->edgeconnect(i+2,newedge[2*((i+2)%3)]);
+      newtr[3]->edgeconnect(i,newedge[6+i]);
+    }
 
-        newtr[0] = new Triang(connect.vtx[0],newvtx[2],newvtx[1]);
-        newtr[1] = new Triang(newvtx[2],connect.vtx[1],newvtx[0]);
-        newtr[2] = new Triang(newvtx[1],newvtx[0],connect.vtx[2]);
-        newtr[3] = new Triang(newvtx[0],newvtx[1],newvtx[2]);
-        for (i=0;i<4;i++) {
-	  newtr[i]->sethdl(hdl);
-	  e[i] = newtr[i];
-	}
-	for (i=0;i<3;i++) {
-	  newtr[i]->edgeconnect(i,newedge[6+i]);
-	  newtr[i]->edgeconnect(i+1,newedge[2*((i+1)%3)+1]);
-	  newtr[i]->edgeconnect(i+2,newedge[2*((i+2)%3)]);
-	  newtr[3]->edgeconnect(i,newedge[6+i]);
-	}
-
         // distribute hanging nodes
 
-        for (i=0;i<3;i++)
-	  {
-	    if (usehvtx[i] == true)
-	      {
-		connect.hvtx[i]->splitTree(newtr[(i+1)%3]->connect.hvtx[i],
-					   newtr[(i+2)%3]->connect.hvtx[i]);
-		delete connect.hvtx[i];
-		connect.hvtx[i] = 0;
-	      } else if (!connect.nb[i]->thinis(bndel_like)) {
-	      ((Element*)connect.nb[i])->addhvtx(newvtx[i],newtr[(i+1)%3],newtr[(i+2)%3],connect.bck[i]);
-	    }
-	  }
+    for (i=0;i<3;i++)
+    {
+      if (usehvtx[i] == true)
+        {
+    connect.hvtx[i]->splitTree(newtr[(i+1)%3]->connect.hvtx[i],
+             newtr[(i+2)%3]->connect.hvtx[i]);
+    delete connect.hvtx[i];
+    connect.hvtx[i] = 0;
+        } else if (!connect.nb[i]->thinis(bndel_like)) {
+        ((Element*)connect.nb[i])->addhvtx(newvtx[i],newtr[(i+1)%3],newtr[(i+2)%3],connect.bck[i]);
+      }
+    }
 
-	// set connectivity for element #3 and normal directions
+  // set connectivity for element #3 and normal directions
 
         for (i=0;i<3;i++)
-	  {
-	    newtr[3]->nbconnect(i,newtr[i],i);
-	    newtr[i]->nbconnect(i,newtr[3],i);
+    {
+      newtr[3]->nbconnect(i,newtr[i],i);
+      newtr[i]->nbconnect(i,newtr[3],i);
 
-	    newtr[3]->setnormdir(i, 1);
-	    newtr[i]->setnormdir(i,-1);
-	    newtr[i]->setnormdir((i+1)%3,connect.normdir[(i+1)%3]);
-	    newtr[i]->setnormdir((i+2)%3,connect.normdir[(i+2)%3]);
-	  }
+      newtr[3]->setnormdir(i, 1);
+      newtr[i]->setnormdir(i,-1);
+      newtr[i]->setnormdir((i+1)%3,connect.normdir[(i+1)%3]);
+      newtr[i]->setnormdir((i+2)%3,connect.normdir[(i+2)%3]);
+    }
 
-	// set connectivity across outer boundaries
+  // set connectivity across outer boundaries
 
         for (i=0;i<3;i++)
-	  {
-	    if (connect.nb[i]->thinis(bndel_like))
-	      {
-		// refine neighbouring boundary element
+    {
+      if (connect.nb[i]->thinis(bndel_like))
+        {
+    // refine neighbouring boundary element
 
-		ncv = new nconf_vtx_t(newvtx[i], newtr[(i+1)%3], newtr[(i+2)%3]);
-		Hier<Bndel>* hbel = (Hier<Bndel>*)connect.nb[i];
-		hbel->refine_leaf(agnc, &mva,ncv,nconfDeg,default_ref,pro_el);
-	      }
-	    else
-	      {
-		// set connectivity if neighbour is already refined
+    ncv = new nconf_vtx_t(newvtx[i], newtr[(i+1)%3], newtr[(i+2)%3]);
+    Hier<Bndel>* hbel = (Hier<Bndel>*)connect.nb[i];
+    hbel->refine_leaf(agnc, &mva,ncv,nconfDeg,default_ref,pro_el);
+        }
+      else
+        {
+    // set connectivity if neighbour is already refined
 
-		if (neighbour(i)->splitrule() == triang_quarter)
-		  {
-		    Triang *trnb0 = (Triang *)neighbour(i);
-		    Triang *trnb1 = (Triang *)(trnb0->down());
-		    Triang *trnb2 = trnb1;
+    if (neighbour(i)->splitrule() == triang_quarter)
+      {
+        Triang *trnb0 = (Triang *)neighbour(i);
+        Triang *trnb1 = (Triang *)(trnb0->down());
+        Triang *trnb2 = trnb1;
 
-		    if (trnb0->is(Refco::quart))
-		      {
-			// This case should only occur if periodic boundaries
-			// are used and the macrogrid is too coarse, i.e., if
-			// there are two elements which are direct and periodic
-			// neighbours at the same time.
+        if (trnb0->is(Refco::quart))
+          {
+      // This case should only occur if periodic boundaries
+      // are used and the macrogrid is too coarse, i.e., if
+      // there are two elements which are direct and periodic
+      // neighbours at the same time.
 
-			cerr << "ERROR (Triang::split()): "
-			     << "refinement of neighbour not yet finished!" << endl
-			     << "                         "
-			     << "Please try a finer macrogrid!" << endl;
-			abort();
-		      }
+      cerr << "ERROR (Triang::split()): "
+           << "refinement of neighbour not yet finished!" << endl
+           << "                         "
+           << "Please try a finer macrogrid!" << endl;
+      abort();
+          }
 
-		    assert(trnb1);
-		    assert(trnb2);
+        assert(trnb1);
+        assert(trnb2);
 
-		    switch (opposite(i))
-		      {
-		      case 0:
-			trnb2 = (Triang *)(trnb2->next());
-			trnb1 = (Triang *)(trnb2->next());
-			break;
-		      case 1:
-			trnb2 = (Triang *)(trnb2->next());
-			trnb2 = (Triang *)(trnb2->next());
-			break;
-		      case 2:
-			trnb1 = (Triang *)(trnb1->next());
-			break;
-		      default:
-			abort();
-		      }
+        switch (opposite(i))
+          {
+          case 0:
+      trnb2 = (Triang *)(trnb2->next());
+      trnb1 = (Triang *)(trnb2->next());
+      break;
+          case 1:
+      trnb2 = (Triang *)(trnb2->next());
+      trnb2 = (Triang *)(trnb2->next());
+      break;
+          case 2:
+      trnb1 = (Triang *)(trnb1->next());
+      break;
+          default:
+      abort();
+          }
 
-		    assert(trnb1->connect.vtx[(opposite(i)+1)%3] == newvtx[i]);
-		    assert(trnb2->connect.vtx[(opposite(i)+2)%3] == newvtx[i]);
+        assert(trnb1->connect.vtx[(opposite(i)+1)%3] == newvtx[i]);
+        assert(trnb2->connect.vtx[(opposite(i)+2)%3] == newvtx[i]);
 
-		    newtr[(i+1)%3]->nbconnect(i,trnb1,opposite(i));
-		    newtr[(i+2)%3]->nbconnect(i,trnb2,opposite(i));
-		    trnb1->nbconnect(opposite(i),newtr[(i+1)%3],i);
-		    trnb2->nbconnect(opposite(i),newtr[(i+2)%3],i);
+        newtr[(i+1)%3]->nbconnect(i,trnb1,opposite(i));
+        newtr[(i+2)%3]->nbconnect(i,trnb2,opposite(i));
+        trnb1->nbconnect(opposite(i),newtr[(i+1)%3],i);
+        trnb2->nbconnect(opposite(i),newtr[(i+2)%3],i);
 
-		    if (newtr[(i+1)%3]->connect.hvtx[i])
-		      newtr[(i+1)%3]->connect.hvtx[i]->nbconnect(opposite(i),newtr[(i+1)%3],i);
-		    if (newtr[(i+2)%3]->connect.hvtx[i])
-		      newtr[(i+2)%3]->connect.hvtx[i]->nbconnect(opposite(i),newtr[(i+2)%3],i);
-		  }
-		else {
-		  assert(neighbour(i)->splitrule() == unsplit);
-		  newtr[(i+1)%3]->nbconnect(i,neighbour(i),opposite(i));
-		  newtr[(i+2)%3]->nbconnect(i,neighbour(i),opposite(i));
-		}
-	      }
-	  }
+        if (newtr[(i+1)%3]->connect.hvtx[i])
+          newtr[(i+1)%3]->connect.hvtx[i]->nbconnect(opposite(i),newtr[(i+1)%3],i);
+        if (newtr[(i+2)%3]->connect.hvtx[i])
+          newtr[(i+2)%3]->connect.hvtx[i]->nbconnect(opposite(i),newtr[(i+2)%3],i);
+      }
+    else {
+      assert(neighbour(i)->splitrule() == unsplit);
+      newtr[(i+1)%3]->nbconnect(i,neighbour(i),opposite(i));
+      newtr[(i+2)%3]->nbconnect(i,neighbour(i),opposite(i));
+    }
+        }
+    }
 
-	/*
-	  if (pro_el)
-	  pro_el->operator()(this, (Element**)newtr, 4);
-	*/
+  /*
+    if (pro_el)
+    pro_el->operator()(this, (Element**)newtr, 4);
+  */
         ret = 4;
       }
       break;
@@ -1577,17 +853,17 @@
   bool ret;
 
   ret = ( (   (splitrule() == triang_quarter)
-	      || (neighbour(0)->splitrule() == triang_quarter)) 
-	  ? false : true);
+        || (neighbour(0)->splitrule() == triang_quarter)) 
+    ? false : true);
 
   if (ret && nbel(0))
     ret = (nbel(0)->deepestLevel() <= nconfDeg); /* &&
-						    (down()->next()->neighbour(0)->thinis(element_like) ?
-						    !(((Element*)(down()->next()->neighbour(0)))->
-						    hashvtx(down()->next()->opposite(0))) : true) &&
-						    (down()->neighbour(0)->thinis(element_like) ?
-						    !(((Element*)(down()->neighbour(0)))->hashvtx(down()->opposite(0)))
-						    : true); */
+                (down()->next()->neighbour(0)->thinis(element_like) ?
+                !(((Element*)(down()->next()->neighbour(0)))->
+                hashvtx(down()->next()->opposite(0))) : true) &&
+                (down()->neighbour(0)->thinis(element_like) ?
+                !(((Element*)(down()->neighbour(0)))->hashvtx(down()->opposite(0)))
+                : true); */
 
   ret = ret && !(down()->hashvtx(0)) && !(down()->next()->hashvtx(0));
 
@@ -1605,111 +881,111 @@
 // #end(method)
 // ***************************************************
 int Triang::docoarsen(nconf_vtx_t *ncv,
-		      int nconfDeg,Restrict_basic *rest_el)
+          int nconfDeg,Restrict_basic *rest_el)
 {
   int result = 0;
   if( nconfDeg == 0 && mysplit == triang_conf2) {
     int lcancoarsen=0;
     if ( connect.nb[0]->thinis(bndel_like) )
       {
-	if ( ((Hier<Bndel>*)connect.nb[0])->docoarsen(ncv,nconfDeg,rest_el) )
-	  {
-	    Hier<Element> *child=down();
-	    child->neighbour(0)->nbconnect(child->opposite(0),this,2);
-	    nbconnect(2,child->neighbour(0),child->opposite(0));
-	    child=child->next();
-	    child->neighbour(0)->nbconnect(child->opposite(0),this,1);
-	    nbconnect(1,child->neighbour(0),child->opposite(0));
-	    if( neighbour(1)->thinis(element_like) ) {
-	      ((Element*)neighbour(1))->setnormdir(opposite(1), 1);
-	      setnormdir(1, -1);
-	    } else
-	      setnormdir(1, 1);
-	    if( neighbour(2)->thinis(element_like) ) {
-	      ((Element*)neighbour(2))->setnormdir(opposite(2), 1);
-	      setnormdir(2, -1);
-	    } else
-	      setnormdir(2, 1);
-	    lcancoarsen=1;
-	  }
+  if ( ((Hier<Bndel>*)connect.nb[0])->docoarsen(ncv,nconfDeg,rest_el) )
+    {
+      Hier<Element> *child=down();
+      child->neighbour(0)->nbconnect(child->opposite(0),this,2);
+      nbconnect(2,child->neighbour(0),child->opposite(0));
+      child=child->next();
+      child->neighbour(0)->nbconnect(child->opposite(0),this,1);
+      nbconnect(1,child->neighbour(0),child->opposite(0));
+      if( neighbour(1)->thinis(element_like) ) {
+        ((Element*)neighbour(1))->setnormdir(opposite(1), 1);
+        setnormdir(1, -1);
+      } else
+        setnormdir(1, 1);
+      if( neighbour(2)->thinis(element_like) ) {
+        ((Element*)neighbour(2))->setnormdir(opposite(2), 1);
+        setnormdir(2, -1);
+      } else
+        setnormdir(2, 1);
+      lcancoarsen=1;
+    }
       }
     else if ( connect.bck[0] == 0 )
       {
-	Hier<Element> *neigh=(Hier<Element>*)connect.nb[0];
-	if ( !ncv )
-	  {
-	    int cancoarsen=1;
-	    neigh=neigh->down();
-	    do
-	      {
-	      } while (   (cancoarsen=(neigh->is(Refco::crs)))
-			  && (neigh=neigh->next()) );
-	    if (cancoarsen)
-	      {
-		Hier<Element> *child=down();
-		ncv = new nconf_vtx(child->vertex(0),child,child->next());
-		assert( ncv );
-		child->neighbour(1)->nbconnect(2,this,-1);
-		child->neighbour(0)->nbconnect(child->opposite(0),this,2);
-		nbconnect(2,child->neighbour(0),child->opposite(0));
-		if( child->neighbour(0)->thinis(element_like) ) {
-		  ((Element*)neighbour(2))->setnormdir(opposite(2), 1);
-		  setnormdir(2, -1);
-		} else
-		  setnormdir(2, 1);
+  Hier<Element> *neigh=(Hier<Element>*)connect.nb[0];
+  if ( !ncv )
+    {
+      int cancoarsen=1;
+      neigh=neigh->down();
+      do
+        {
+        } while (   (cancoarsen=(neigh->is(Refco::crs)))
+        && (neigh=neigh->next()) );
+      if (cancoarsen)
+        {
+    Hier<Element> *child=down();
+    ncv = new nconf_vtx(child->vertex(0),child,child->next());
+    assert( ncv );
+    child->neighbour(1)->nbconnect(2,this,-1);
+    child->neighbour(0)->nbconnect(child->opposite(0),this,2);
+    nbconnect(2,child->neighbour(0),child->opposite(0));
+    if( child->neighbour(0)->thinis(element_like) ) {
+      ((Element*)neighbour(2))->setnormdir(opposite(2), 1);
+      setnormdir(2, -1);
+    } else
+      setnormdir(2, 1);
 
-		child=child->next();
-		child->neighbour(2)->nbconnect(1,this,-1);
-		child->neighbour(0)->nbconnect(child->opposite(0),this,1);
-		nbconnect(1,child->neighbour(0),child->opposite(0));
-		if( child->neighbour(0)->thinis(element_like) ) {
-		  ((Element*)neighbour(1))->setnormdir(opposite(1), 1);
-		  setnormdir(1, -1);
-		} else
-		  setnormdir(1, 1);
-		setnormdir(0, -1);
+    child=child->next();
+    child->neighbour(2)->nbconnect(1,this,-1);
+    child->neighbour(0)->nbconnect(child->opposite(0),this,1);
+    nbconnect(1,child->neighbour(0),child->opposite(0));
+    if( child->neighbour(0)->thinis(element_like) ) {
+      ((Element*)neighbour(1))->setnormdir(opposite(1), 1);
+      setnormdir(1, -1);
+    } else
+      setnormdir(1, 1);
+    setnormdir(0, -1);
           
 #ifndef NDEBUG
-		// only used in assert 
-		bool didcoarse = 
+    // only used in assert 
+    bool didcoarse = 
 #endif
-		  // do coarsen 
-		  ((Hier<Element>*)connect.nb[0])->docoarsen(ncv,nconfDeg,rest_el);
-		assert( didcoarse );
-		lcancoarsen=1;
-	      }
-	  }
-	else
-	  {
-	    Hier<Element> *child=down();
-	    child->neighbour(0)->nbconnect(child->opposite(0),this,2);
-	    nbconnect(2,child->neighbour(0),child->opposite(0));
-	    if( child->neighbour(0)->thinis(element_like) ) {
-	      ((Element*)neighbour(2))->setnormdir(opposite(2), 1);
-	      setnormdir(2, -1);
-	    } else
-	      setnormdir(2, 1);
+      // do coarsen 
+      ((Hier<Element>*)connect.nb[0])->docoarsen(ncv,nconfDeg,rest_el);
+    assert( didcoarse );
+    lcancoarsen=1;
+        }
+    }
+  else
+    {
+      Hier<Element> *child=down();
+      child->neighbour(0)->nbconnect(child->opposite(0),this,2);
+      nbconnect(2,child->neighbour(0),child->opposite(0));
+      if( child->neighbour(0)->thinis(element_like) ) {
+        ((Element*)neighbour(2))->setnormdir(opposite(2), 1);
+        setnormdir(2, -1);
+      } else
+        setnormdir(2, 1);
 
-	    child=child->next();
-	    child->neighbour(0)->nbconnect(child->opposite(0),this,1);
-	    nbconnect(1,child->neighbour(0),child->opposite(0));
-	    if( child->neighbour(0)->thinis(element_like) ) {
-	      ((Element*)neighbour(1))->setnormdir(opposite(1), 1);
-	      setnormdir(1, -1);
-	    } else
-	      setnormdir(1, 1);
-	    setnormdir(0, 1);
+      child=child->next();
+      child->neighbour(0)->nbconnect(child->opposite(0),this,1);
+      nbconnect(1,child->neighbour(0),child->opposite(0));
+      if( child->neighbour(0)->thinis(element_like) ) {
+        ((Element*)neighbour(1))->setnormdir(opposite(1), 1);
+        setnormdir(1, -1);
+      } else
+        setnormdir(1, 1);
+      setnormdir(0, 1);
 
-	    delete ncv;
-	    ncv=0;
-	    Element *e[2];
-	    e[0]=down();
-	    e[1]=down()->next();
-	    // rest_el->operator()(this,e,2);
-	    if (rest_el) 
-	      rest_el->operator()(this);
-	    lcancoarsen=2;
-	  }
+      delete ncv;
+      ncv=0;
+      Element *e[2];
+      e[0]=down();
+      e[1]=down()->next();
+      // rest_el->operator()(this,e,2);
+      if (rest_el) 
+        rest_el->operator()(this);
+      lcancoarsen=2;
+    }
       }
     if( lcancoarsen != 0 && rest_el) {
       Element *e[2];
@@ -1717,7 +993,7 @@
       e[1]=down()->next();
       //rest_el->operator()(this,e,2);
       if (rest_el)
-	rest_el->operator()(this);
+  rest_el->operator()(this);
     }
     if (lcancoarsen==2) {
       deletesubtree();
@@ -1729,74 +1005,74 @@
     Element *child[3]={down(),down()->next(),down()->next()->next()};
     for (int i=0;i<3;i++) {
       if (nbel(i)) {
-	if (!(nbel(i)->leaf()) && child[(i+1)%3]->hashvtx(i)) {
-	  if (((Triang*)child[(i+1)%3])->connect.hvtx[i]->count()+1>nconfDeg)
-	    lcancoarsen=0;
-	}
-	if (!(nbel(i)->leaf()) && child[(i+2)%3]->hashvtx(i)) {
-	  if (((Triang*)child[(i+2)%3])->connect.hvtx[i]->count()+1>nconfDeg)
-	    lcancoarsen=0;
-	}
+  if (!(nbel(i)->leaf()) && child[(i+1)%3]->hashvtx(i)) {
+    if (((Triang*)child[(i+1)%3])->connect.hvtx[i]->count()+1>nconfDeg)
+      lcancoarsen=0;
+  }
+  if (!(nbel(i)->leaf()) && child[(i+2)%3]->hashvtx(i)) {
+    if (((Triang*)child[(i+2)%3])->connect.hvtx[i]->count()+1>nconfDeg)
+      lcancoarsen=0;
+  }
       } 
     }
     if (lcancoarsen) {
       if (rest_el) 
-	rest_el->operator()(this);
+  rest_el->operator()(this);
       if (0) {
-	//Xdisplay disp(g_argc,g_argv,"a","Grid",
-	//	      350.,450.,450.);
-	double p1[2],p2[2];
-	double bary[3]={1./3.,1./3.,1./3.};
+  //Xdisplay disp(g_argc,g_argv,"a","Grid",
+  //        350.,450.,450.);
+  double p1[2],p2[2];
+  double bary[3]={1./3.,1./3.,1./3.};
 #ifdef USE_ALUGRID_XDISPLAY
-	mesh->draw(disp);
+  mesh->draw(disp);
 #endif
-	{
-	  this->fromlocal(bary,p1);
-	  this->fromlocal(bary,p2);
-	  p1[0]-=0.05;
-	  p1[1]-=0.05;
-	  p2[0]+=0.05;
-	  p2[1]+=0.05;
-	  Fullvertex pp1(p1,-1);
-	  Fullvertex pp2(p2,-1);
-	  //disp.linedraw(&pp1,&pp2,disp.bcol[17]);
-	}
-	{
-	  this->fromlocal(bary,p1);
-	  this->fromlocal(bary,p2);
-	  p1[0]-=0.05;
-	  p1[1]+=0.05;
-	  p2[0]+=0.05;
-	  p2[1]-=0.05;
-	  Fullvertex pp1(p1,-1);
-	  Fullvertex pp2(p2,-1);
-	  //disp.linedraw(&pp1,&pp2,disp.bcol[17]);
-	}
+  {
+    this->fromlocal(bary,p1);
+    this->fromlocal(bary,p2);
+    p1[0]-=0.05;
+    p1[1]-=0.05;
+    p2[0]+=0.05;
+    p2[1]+=0.05;
+    Fullvertex pp1(p1,-1);
+    Fullvertex pp2(p2,-1);
+    //disp.linedraw(&pp1,&pp2,disp.bcol[17]);
+  }
+  {
+    this->fromlocal(bary,p1);
+    this->fromlocal(bary,p2);
+    p1[0]-=0.05;
+    p1[1]+=0.05;
+    p2[0]+=0.05;
+    p2[1]-=0.05;
+    Fullvertex pp1(p1,-1);
+    Fullvertex pp2(p2,-1);
+    //disp.linedraw(&pp1,&pp2,disp.bcol[17]);
+  }
       }
       // Nachbarschaften stimmen (hoffe ich)
       // Haengende Knoten verwalten
       for (int i=0;i<3;i++) {
-	assert(!hashvtx(i));
-	if (nbel(i)) {
-	  if (!(nbel(i)->leaf())) { // Haengenden Knoten erzeugen 
-	    addhvtx(child[(i+1)%3]->vertex((i+2)%3), 
-		    child[(i+2)%3]->nbel(i),child[(i+1)%3]->nbel(i), i);
-	    connect.hvtx[i]->merge(((Triang*)child[(i+1)%3])->connect.hvtx[i],
-	    			   ((Triang*)child[(i+2)%3])->connect.hvtx[i]);
-	    connect.hvtx[i]->nbconnect(opposite(i),this,i);
-	  } else { // Haengenden Knoten im Nachbarn entfernen 
-	    assert(nbel(i)->hashvtx(opposite(i)));
-	    nbel(i)->removehvtx(opposite(i),child[(i+1)%3]->vertex((i+2)%3));
-	  }
-	}
+  assert(!hashvtx(i));
+  if (nbel(i)) {
+    if (!(nbel(i)->leaf())) { // Haengenden Knoten erzeugen 
+      addhvtx(child[(i+1)%3]->vertex((i+2)%3), 
+        child[(i+2)%3]->nbel(i),child[(i+1)%3]->nbel(i), i);
+      connect.hvtx[i]->merge(((Triang*)child[(i+1)%3])->connect.hvtx[i],
+               ((Triang*)child[(i+2)%3])->connect.hvtx[i]);
+      connect.hvtx[i]->nbconnect(opposite(i),this,i);
+    } else { // Haengenden Knoten im Nachbarn entfernen 
+      assert(nbel(i)->hashvtx(opposite(i)));
+      nbel(i)->removehvtx(opposite(i),child[(i+1)%3]->vertex((i+2)%3));
+    }
+  }
       }
       for (int i=0;i<3;i++) {
-	if (nbbnd(i)) {
-	  if( !(nbbnd(i)->docoarsen(ncv,nconfDeg,rest_el)) ) {
-	    lcancoarsen=0;
-	    assert(0);
-	  }
-	}
+  if (nbbnd(i)) {
+    if( !(nbbnd(i)->docoarsen(ncv,nconfDeg,rest_el)) ) {
+      lcancoarsen=0;
+      assert(0);
+    }
+  }
       }
     } 
     result = lcancoarsen;
@@ -1825,14 +1101,14 @@
   for (int i=0;i<nf;i++)
     {
       if (nb[i]->thinis(element_like))
-	{
-	  assert( 0<=bck[i] && bck[i]<=nf );
-	}
+  {
+    assert( 0<=bck[i] && bck[i]<=nf );
+  }
       else
-	{
-	  assert( bck[i] == 0 );
-	  assert( normdir[i] == 1 );
-	}
+  {
+    assert( bck[i] == 0 );
+    assert( normdir[i] == 1 );
+  }
       assert( normdir[i]==1 || normdir[i]==-1 );
       assert(edge[i]);
       assert(edge[i]->getIndex()>=0);
@@ -1862,29 +1138,29 @@
   for (int i=0;i<3;i++)
     {
       if(  connect.nb[i]->thinis(element_like) )
-	{
-	  if(  !connect.hvtx[i] &&
-	       !(((Triang*)neighbour(i))->hashvtx(opposite(i))) ) { // Konform
-	    assert( connect.nb[i]->opposite(connect.bck[i])==i );
-	    assert( connect.nb[i]->neighbour(connect.bck[i])==this );
-	    assert( connect.nb[i]->edge(connect.bck[i])==connect.edge[i]);
-	    assert( connect.nb[i]->vertex(connect.bck[i]+1)==vertex(i+2) );
-	    assert( connect.nb[i]->vertex(connect.bck[i]+2)==vertex(i+1) );
-	  } else if (connect.hvtx[i]) {
-	    assert(!(((Triang*)neighbour(i))->hashvtx(opposite(i))));
-	    assert( connect.hvtx[i]->getlnb()->neighbour(opposite(i))==this);
-	    assert( connect.hvtx[i]->getrnb()->neighbour(opposite(i))==this);
-	  }
-	  assert(((Element*)neighbour(i))->normaldir(opposite(i)) == -normaldir(i));
-	}
+  {
+    if(  !connect.hvtx[i] &&
+         !(((Triang*)neighbour(i))->hashvtx(opposite(i))) ) { // Konform
+      assert( connect.nb[i]->opposite(connect.bck[i])==i );
+      assert( connect.nb[i]->neighbour(connect.bck[i])==this );
+      assert( connect.nb[i]->edge(connect.bck[i])==connect.edge[i]);
+      assert( connect.nb[i]->vertex(connect.bck[i]+1)==vertex(i+2) );
+      assert( connect.nb[i]->vertex(connect.bck[i]+2)==vertex(i+1) );
+    } else if (connect.hvtx[i]) {
+      assert(!(((Triang*)neighbour(i))->hashvtx(opposite(i))));
+      assert( connect.hvtx[i]->getlnb()->neighbour(opposite(i))==this);
+      assert( connect.hvtx[i]->getrnb()->neighbour(opposite(i))==this);
+    }
+    assert(((Element*)neighbour(i))->normaldir(opposite(i)) == -normaldir(i));
+  }
       else
-	{
-	  assert( connect.nb[i]->neighbour(0)==this );
-	  assert( connect.nb[i]->vertex(0)==vertex(i+1) );
-	  assert( connect.nb[i]->vertex(1)==vertex(i+2) );
-	  assert( connect.nb[i]->opposite(0)==i );
-	  assert( connect.nb[i]->edge(connect.bck[i])==connect.edge[i]);
-	}
+  {
+    assert( connect.nb[i]->neighbour(0)==this );
+    assert( connect.nb[i]->vertex(0)==vertex(i+1) );
+    assert( connect.nb[i]->vertex(1)==vertex(i+2) );
+    assert( connect.nb[i]->opposite(0)==i );
+    assert( connect.nb[i]->edge(connect.bck[i])==connect.edge[i]);
+  }
     }
   if ( ((Hier<Element>*)this)->leaf()) {
   }
@@ -2031,7 +1307,7 @@
 void Bndel_triang::restrictLocal(Bndel **pbel, int pnr)
 {
   assert(   ((Bndel_triang*)(pbel[0]))->time
-	    == ((Bndel_triang*)(pbel[1]))->time);
+      == ((Bndel_triang*)(pbel[1]))->time);
 
   time = ((Bndel_triang*)(pbel[0]))->time; 
 }
@@ -2044,10 +1320,10 @@
 
 int Bndel_triang::split(void * (&e)[nparts], Listagency < Vertex > * agnc,
                         Multivertexadapter & mva, 
-			nconf_vtx_t *ncv,
-			splitrule_t sr,
-			int nconfDeg,Refco::tag_t default_ref,
-			Prolong_basic *pro_el)
+      nconf_vtx_t *ncv,
+      splitrule_t sr,
+      int nconfDeg,Refco::tag_t default_ref,
+      Prolong_basic *pro_el)
 {
   int idx[2];
   //  nconf_vtx_t *ncv;
@@ -2076,7 +1352,7 @@
       break;
     default:
       cerr << "ERROR (Bndel_triang::split()): "
-	   << "illegal splitrule!" << endl;
+     << "illegal splitrule!" << endl;
       abort();
     }
 
@@ -2088,13 +1364,20 @@
   ((Element*)ncv->el[1])->setnormdir(idx[1],1);
   t1->nbconnect(0,ncv->el[0],idx[0]);
   t2->nbconnect(0,ncv->el[1],idx[1]);
+
+#ifdef ALU2D_OLD_BND_PROJECTION  
   t1->set_bndfunctions(lf,lDf);
   t2->set_bndfunctions(lf,lDf);
+#else 
+  t1->copySegmentIndex( _segmentIndex );
+  t2->copySegmentIndex( _segmentIndex );
+#endif
   //      mva.delete(connect.vtx[1],connect.vtx[2]);    
   
   // Daten auf dem Rand prolongieren
-  t1->sethdl(hdl);
-  t2->sethdl(hdl);
+  t1->sethdl( hdl );
+  t2->sethdl( hdl );
+
   t1->edgeconnect(0,ncv->el[0]->edge(idx[0]));
   t2->edgeconnect(0,ncv->el[1]->edge(idx[1]));
   e[0]=t1;
@@ -2108,7 +1391,7 @@
 }
 
 int Bndel_triang::docoarsen(nconf_vtx_t *ncv,
-			    int nconfDeg,Restrict_basic *rest_el)
+          int nconfDeg,Restrict_basic *rest_el)
 {
   assert(splitrule() == triang_bnd);
 
@@ -2126,10 +1409,10 @@
 
 int Bndel_periodic::split(void * (&el)[nparts], Listagency < Vertex > * agnc,
                           Multivertexadapter & mva, 
-			  nconf_vtx_t *ncv,
-			  splitrule_t sr,
-			  int nconfDeg,Refco::tag_t default_ref,
-			  Prolong_basic *pro_el)
+        nconf_vtx_t *ncv,
+        splitrule_t sr,
+        int nconfDeg,Refco::tag_t default_ref,
+        Prolong_basic *pro_el)
 {
   assert(sr == triang_bnd);
   assert(splitrule() == unsplit);
@@ -2141,20 +1424,20 @@
     periodic_flag=1;
     while (periodic_nb->leaf())
       {
-	switch (nbel(0)->splitrule())
-	  {
-	  case Thinelement::triang_conf2:
-	    periodic_nb->nbel(0)->Refco_el::mark(Refco::ref_1) ;
-	    break;
-	  case Thinelement::triang_quarter:
-	    periodic_nb->nbel(0)->Refco_el::mark(Refco::quart) ;
-	    break;
-	  default:
-	    cerr << "ERROR (Bndel_periodic::split()): "
-		 << "illegal splitrule!" << endl;
-	    abort();
-	  }
-	periodic_nb->nbel(0)->refine_leaf(agnc,&mva,ncv,nconfDeg,default_ref,pro_el);
+  switch (nbel(0)->splitrule())
+    {
+    case Thinelement::triang_conf2:
+      periodic_nb->nbel(0)->Refco_el::mark(Refco::ref_1) ;
+      break;
+    case Thinelement::triang_quarter:
+      periodic_nb->nbel(0)->Refco_el::mark(Refco::quart) ;
+      break;
+    default:
+      cerr << "ERROR (Bndel_periodic::split()): "
+     << "illegal splitrule!" << endl;
+      abort();
+    }
+  periodic_nb->nbel(0)->refine_leaf(agnc,&mva,ncv,nconfDeg,default_ref,pro_el);
       }
     periodic_flag=0;
     ((Bndel_periodic*)(el[0]))
@@ -2183,13 +1466,13 @@
       ((Bndel_periodic*)el[1])->set_pnb(periodic_nb);
     } else {
       ((Bndel_periodic*)el[0])
-	->set_pnb((Bndel_periodic*)(periodic_nb->down()->next()));
+  ->set_pnb((Bndel_periodic*)(periodic_nb->down()->next()));
       ((Bndel_periodic*)(periodic_nb->down()->next()))
-	->set_pnb((Bndel_periodic*)el[0]);
+  ->set_pnb((Bndel_periodic*)el[0]);
       ((Bndel_periodic*)el[1])
-	->set_pnb((Bndel_periodic*)(periodic_nb->down()));
+  ->set_pnb((Bndel_periodic*)(periodic_nb->down()));
       ((Bndel_periodic*)(periodic_nb->down()))
-	->set_pnb((Bndel_periodic*)el[1]);
+  ->set_pnb((Bndel_periodic*)el[1]);
     }
 
   }
@@ -2198,7 +1481,7 @@
 }
 
 int Bndel_periodic::docoarsen(nconf_vtx_t *ncv,
-			      int nconfDeg,Restrict_basic *rest_el)
+            int nconfDeg,Restrict_basic *rest_el)
 {
   if(nconfDeg == 0 ) {
     if (periodic_nb->leaf())
@@ -2212,9 +1495,9 @@
 
     while (h)
       {
-	if (!h->is(Refco::crs))
-	  break;
-	h=h->next();
+  if (!h->is(Refco::crs))
+    break;
+  h=h->next();
       }
     if (h)
       return 0;
Index: alu2d/triang.h
===================================================================
--- alu2d/triang.h	(revision 1064)
+++ alu2d/triang.h	(revision 1173)
@@ -79,7 +79,13 @@
 
   public :
 
-    Bndel_triang(Bndel::bnd_t t) : time(0.0) {typ=t;}
+    Bndel_triang(const int segmentIndex, 
+                 Bndel::bnd_t t) 
+      : time(0.0) 
+    {
+      typ = t ;
+      this->copySegmentIndex( segmentIndex );
+    }
 
     // Bndel_triang() : time(0.0) {typ=-111;}
 
@@ -117,9 +123,13 @@
     Bndel_periodic *periodic_nb;
 
     Bndel_periodic()
-      : Bndel_triang(periodic),periodic_nb(0)
+      : Bndel_triang(-1,periodic), periodic_nb(0)
       { }
 
+    Bndel_periodic(const int segmentIndex)
+      : Bndel_triang(segmentIndex, periodic), periodic_nb(0)
+      { }
+
     Bndel_periodic(Vertex *v1 , Vertex *v2)
       : Bndel_triang(v1,v2,periodic),periodic_nb(0)
       { }
Index: alu2d/grid.h
===================================================================
--- alu2d/grid.h	(revision 1064)
+++ alu2d/grid.h	(revision 1173)
@@ -23,11 +23,18 @@
 // #end(header)
 ***************************************************/
 
-#include "../indexstack.h"
-
 #include "xdisplay.h"
 #include "vtx_btree.h"
 
+//****************************************************************
+//
+// Vertex Projection 
+//
+//****************************************************************
+typedef VertexProjection<2> ProjectVertex_t;
+
+//****************************************************************
+
 class Hmesh_basic;
 class Hmesh;
 class Basic {
@@ -384,10 +391,6 @@
 
     int numvertices() const { return nvertices ; }
 
-    //virtual double area() const = 0;
-
-    //virtual void edge_vtx(int , Vertex * (&) [2]) const = 0 ;
-
     virtual int numfacevertices(int ) const = 0 ;
     
     virtual int facevertex(int , int ) const = 0 ;
@@ -400,12 +403,11 @@
 
     virtual int opposite(int fce) const = 0 ;
 
-    //virtual int edge_idx(int fce) const = 0 ;
-
     virtual Edge *edge(int fce) const = 0 ;
 
     virtual void nbconnect(int , Thinelement *, int ) = 0 ;
 
+    virtual int segmentIndex() const = 0;
 
     virtual void write(ofstream &) const = 0 ;
 
@@ -558,6 +560,8 @@
       
     void edge_vtx(int e, Vertex * (& ) [2] ) const ;
 
+    // this is not a boundary segment and thus return negtive value 
+    int segmentIndex() const { return -1; }
 
     Vertex * vertex(int ) const ;
 
@@ -904,13 +908,11 @@
     enum {nf=1,nv=2};
 
     Vertex * vtx[max_points] ;
-
     Thinelement * nb ;
+    Edge *edge;
 
     short int bck ;
 
-    Edge *edge;
-
     c() ;
 
    ~c() ;
@@ -941,13 +943,16 @@
  
   protected :
 
-    Bndel(bnd_t t = none) : typ(t) { }
+    Bndel(bnd_t t = none) : typ(t) , _segmentIndex( -1 ) { }
 
     bnd_t typ ;
 
+#ifdef ALU2D_OLD_BND_PROJECTION
     double (*lf)(double);
-
     double (*lDf)(double);
+#else 
+    int _segmentIndex;
+#endif
  
   public :
 
@@ -962,7 +967,6 @@
     int facevertex(int , int ) const ;
 
     int numfacevertices(int ) const { return connect.nv ; }
-
  
     void edge_vtx(int e, Vertex * (& ) [2] ) const ;
 
@@ -971,7 +975,13 @@
  
     Vertex * vertex(int , int j) const { return vertex(j) ; }
 
+    int segmentIndex() const 
+    { 
+      assert( _segmentIndex >= 0 );
+      return _segmentIndex; 
+    }
 
+
     Thinelement * neighbour(int ) const { return connect.nb ; }
 
     int neighbours(int ) const { return 1; }
@@ -985,11 +995,18 @@
     void nbconnect(int , Thinelement * , int ) ;
     void edgeconnect(int , Edge *) ;
 
+#ifdef ALU2D_OLD_BND_PROJECTION
     void set_bndfunctions(double (*pf)(double), double (*pDf)(double))
     {
       lf  = pf;
       lDf = pDf;
     }
+#else 
+    void copySegmentIndex(const int segmentIndex)
+    {
+      _segmentIndex = segmentIndex;
+    }
+#endif
 
     int get_splitpoint(double (& ) [2]) ;
 
Index: alu2d/grid_imp.cc
===================================================================
--- alu2d/grid_imp.cc	(revision 1064)
+++ alu2d/grid_imp.cc	(revision 1173)
@@ -210,28 +210,33 @@
 
 inline int Bndel::get_splitpoint(double (&ppoint) [2])
 {
-  const double EPS = 1e-8;
-  const int lmax_iter = 1000;
-  const double ltol   = 1e-12;
+  const double (&c0)[2] = connect.vtx[0]->coord();
+  const double (&c1)[2] = connect.vtx[1]->coord();
 
-  double ldiv,lx,ly,lcx,lcy,lvx=0.0,lvy=0.0,lt=0.0;
-  int li=0,lret=0;
+  ppoint[0] = 0.5 * ( c0[0] + c1[0] );//connect.vtx[0]->coord()[0]+connect.vtx[1]->coord()[0]);
+  ppoint[1] = 0.5 * ( c0[1] + c1[1] );//connect.vtx[0]->coord()[1]+connect.vtx[1]->coord()[1]);
 
-  lcx = 0.5*(connect.vtx[0]->coord()[0]+connect.vtx[1]->coord()[0]);
-  lcy = 0.5*(connect.vtx[0]->coord()[1]+connect.vtx[1]->coord()[1]);
+  // old method, new method below 
+#ifdef ALU2D_OLD_BND_PROJECTION
+  if (lf && lDf)
+  {
+    const double EPS = 1e-8;
+    const int lmax_iter = 1000;
+    const double ltol   = 1e-12;
 
-  if (0 && lf && lDf)
-  {
+    int li=0,lret=0;
+
+    double ldiv,lx,ly,lvx=0.0,lvy=0.0,lt=0.0;
     assert(fabs(  lf(connect.vtx[0]->coord()[0])
                 - connect.vtx[0]->coord()[1]) <= 2.0 * ltol);
     assert(fabs(  lf(connect.vtx[1]->coord()[0])
-		- connect.vtx[1]->coord()[1]) <= 2.0 * ltol);
+    - connect.vtx[1]->coord()[1]) <= 2.0 * ltol);
 
     lvx = connect.vtx[0]->coord()[1] - connect.vtx[1]->coord()[1];
     lvy = connect.vtx[1]->coord()[0] - connect.vtx[0]->coord()[0];
 
-    lx  = lcx;
-    ly  = lcy;
+    lx  = ppoint[0];
+    ly  = ppoint[1];
 
     do
     {
@@ -240,8 +245,8 @@
       {
         lt -= (lf(lx) - ly) / ldiv;
 
-        lx = lcx + lt * lvx;
-        ly = lcy + lt * lvy;
+        lx = ppoint[0] + lt * lvx;
+        ly = ppoint[1] + lt * lvy;
       }
       else
       {
@@ -259,11 +264,17 @@
     {
       lret = 1;
     }
+
+    ppoint[0] += lt * lvx;
+    ppoint[1] += lt * lvy;
   }
+#else // use new method 
 
-  ppoint[0] = lcx + lt * lvx;
-  ppoint[1] = lcy + lt * lvy;
+  // apply vertex projection, if existent 
+  this->hdl->projectVertex( _segmentIndex, ppoint );
 
+#endif
+
   return 0;
 }
 
@@ -308,7 +319,7 @@
     {
       connect.edge[i]->detach();
       if (connect.edge[i]->isfree())
-	    delete connect.edge[i];
+      delete connect.edge[i];
     }
   }
   assert(hdl);
@@ -1027,9 +1038,9 @@
   o=(v1[0]-v0[0])*(v2[1]-v1[1])-(v1[1]-v0[1])*(v2[0]-v1[0]);
   if (fabs(o)<1e-10) {
     cerr << o << " " 
-	 << v0[0] << "," << v0[1] << " "
-	 << v1[0] << "," << v1[1] << " "
-	 << v2[0] << "," << v2[1] << endl;
+   << v0[0] << "," << v0[1] << " "
+   << v1[0] << "," << v1[1] << " "
+   << v2[0] << "," << v2[1] << endl;
   }
   assert(o);  // Entartet!
   if (o<0)    // Orientierung im Uhrzeigersinn!
Index: alugrid_parallel.cc
===================================================================
--- alugrid_parallel.cc	(revision 1064)
+++ alugrid_parallel.cc	(revision 1173)
@@ -1,6 +1,8 @@
 #ifndef __ALUGRID_PARALLEL_CC_INCLUDED__
 #define __ALUGRID_PARALLEL_CC_INCLUDED__
 
+#include <config.h>
+
 #include "alugrid_parallel.h"
 
 #ifndef NDEBUG
@@ -9,66 +11,59 @@
 
 #define _ANSI_HEADER 
 
-// partitioning libs 
-// METIS if not found here then dummy version is included 
-extern "C" {
-// METISTITLE is defined by the metis header file. 
-#undef METISTITLE 
-#undef METIS_H 
 
-// cover metis-4.0 bug   
-#define __log2 __METIS__log2
-// include metis header   
-#include <metis.h>
-// undef again 
-#undef __log2
+// avoid C++ bindings of MPI (-DMPIPP_H is not common enough)
+// this is the only thing all MPI implementations have in common
+// to do that we pretend that we are compiling C code 
+#if defined(__cplusplus) 
+#define rem__cplusplus __cplusplus
+#undef __cplusplus
+#endif
 
-// if METISTITLE is still undefined then the dummy is included 
-#include "parallel/metis.c"
-}
+#if defined(c_plusplus) 
+#define remc_plusplus c_plusplus
+#undef c_plusplus
+#endif
 
-/*
-// partitioning libs 
-// ParMETIS if not found here then dummy version is included 
 extern "C" {
-//  __parmetis_h__ is defined by the parmetis header file. 
-#include <parmetis.h>
-// if __parmetis_h__ is still undefined then the dummy is included 
-#include "parallel/parmetis.c"
+  // the message passing interface (MPI) headers for C 
+  #include <mpi.h>
 }
-*/
 
-// PARTY_LIB if not found here then dummy version is included 
-#ifdef VERSION 
-#define _VER_SAVE VERSION 
-#undef VERSION 
+// restore defines 
+#if defined(rem__cplusplus) 
+#define __cplusplus rem__cplusplus
+#undef rem__cplusplus
 #endif
 
-extern "C" {
-// include PARTY lib header 
-#include <party_lib.h>
-}
-#if defined VERSION && defined VW
-#define PARTY_LIB_H_INCLUDED
-#ifdef _VER_SAVE
-#undef VERSION 
-#define VERSION _VER_SAVE
-#endif // end _VER_SAVE 
-#else 
-#include "parallel/party_lib.c"
+#if defined(c_plusplus) 
+#define c_plusplus remc_plusplus
+#undef remc_plusplus
 #endif
 
+
+// ParMETIS stuff 
+#include "parallel/aluparmetis.hh"
+
+// METIS stuff 
+#include "parallel/alumetis.hh"
+
+// PARTY Lib stuff 
+#include "parallel/aluparty_lib.hh"
+
+
 namespace ALUGridSpace {
 
 #include "parallel/gitter_pll_sti.cc"
-#include "parallel/gitter_pll_ldb.cc"
 #include "parallel/gitter_pll_impl.cc"
 #include "parallel/gitter_pll_sti.cc"
 #include "parallel/gitter_pll_mgb.cc"
-#include "parallel/gitter_pll_idn.cc"
+
 #include "parallel/mpAccess.cc"
-#include "parallel/mpAccess_MPI.cc"
+#include "parallel/mpAccess_MPI.cc"  
 
+#include "parallel/gitter_pll_ldb.cc"
+#include "parallel/gitter_pll_idn.cc"
 // file for duneinterface 
 #include "duneinterface/gitter_dune_pll_impl.cc"
 
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 1064)
+++ Makefile.am	(revision 1173)
@@ -16,27 +16,24 @@
 lib_LTLIBRARIES = libalugrid.la
 
 # headers to install 
-nobase_include_HEADERS = alugrid_serial.h alugrid_parallel.h alugrid_2d.h alugrid_2d.cc stlheaders.h indexstack.h $(serialhdrs) $(parallelhdrs) $(duneinterfacehdrs) $(alu2dhdrs)
+nobase_include_HEADERS = alugrid_serial.h alugrid_parallel.h alugrid_2d.h alugrid_2d.cc stlheaders.h indexstack.h projectvertex.h $(serialhdrs) $(parallelhdrs) $(duneinterfacehdrs) $(alu2dhdrs)
 
+# add all package flags 
+AM_CPPFLAGS = $(ALUGRID_CPPFLAGS)
+libalugrid_la_CPPFLAGS = $(ALUGRID_CPPFLAGS) $(ALL_PKG_CPPFLAGS)
+libalugrid_la_LIBADD = $(PARMETIS_LDFLAGS) $(PARMETIS_LIBS) $(METIS_LDFLAGS) $(METIS_LIBS) $(MPI_LDFLAGS) $(MPI_LIBS) 
+
 if MPI 
 # if MPI was found the parallel version is build 
 include_HEADERS = parallel/alugrid_defineparallel.h
 
-# add mpi path to cpplags 
-AM_CPPFLAGS = $(ALUGRID_CPPFLAGS) $(MPI_CPPFLAGS)
-LDADD = $(ALL_PKG_LDFLAGS) $(ALL_PKG_LIBS)
-
 # build lib with parallel support 
 dist_libalugrid_la_SOURCES = alugrid_serial.cc alugrid_parallel.cc alugrid_2d.cc
-libalugrid_la_LIBADD = $(PARTY_LDFLAGS) $(PARTY_LIBS) $(PARMETIS_LDFLAGS) $(PARMETIS_LIBS) $(METIS_LDFLAGS) $(METIS_LIBS)
 
 else 
 # if no mpi build only serial lib 
 include_HEADERS = serial/alugrid_defineparallel.h
 
-LDADD = $(ALL_PKG_LDFLAGS) $(ALL_PKG_LIBS)
-AM_CPPFLAGS = $(ALUGRID_CPPFLAGS)
 # build only serial grid lib
 dist_libalugrid_la_SOURCES = alugrid_serial.cc alugrid_2d.cc
-
 endif
Index: alugrid_parallel.h
===================================================================
--- alugrid_parallel.h	(revision 1064)
+++ alugrid_parallel.h	(revision 1173)
@@ -1,13 +1,6 @@
 #ifndef _ALUGRID_PARALLEL_h_INCLUDED_
 #define _ALUGRID_PARALLEL_h_INCLUDED_
 
-// is this is defined the internal faces are used as ghost elements 
-// needs to be defined before all headers are included 
-//#define __USE_INTERNAL_FACES__
-
-// the message passing interface (MPI) headers 
-#include <mpi.h>
-
 #include "alugrid_serial.h"
 
 #define _ANSI_HEADER 
@@ -28,5 +21,4 @@
 #include "duneinterface/gitter_dune_pll_impl.h"
 
 }
-
 #endif
Index: projectvertex.h
===================================================================
--- projectvertex.h	(revision 0)
+++ projectvertex.h	(revision 1173)
@@ -0,0 +1,27 @@
+// (c) Robert Kloefkorn 2004 - 2010 
+#ifndef ALUGRIDVERTEXPROJECTION_H_INCLUDED
+#define ALUGRIDVERTEXPROJECTION_H_INCLUDED
+
+namespace ALUGridSpace {
+
+// use standard namespace 
+using namespace std;
+
+// interface class for projecting vertices for boundary adjustment 
+template <int dim> 
+class VertexProjection
+{
+protected:
+  // don't allow creation of an instance  
+  VertexProjection () {}
+public:
+  // destructor 
+  virtual ~VertexProjection() {}
+  // projection method 
+  virtual int operator()(const double (&p)[dim],
+                         const int segmentIndex,
+                         double (&ret)[dim]) const = 0;
+};
+
+} // end namespace 
+#endif
Index: alugrid_serial.h
===================================================================
--- alugrid_serial.h	(revision 1064)
+++ alugrid_serial.h	(revision 1173)
@@ -11,12 +11,17 @@
 // if DUNE_NOT_USES_ALUGRID is defined, then index management is deactivated
 //#define _DUNE_NOT_USES_ALU3DGRID_
 
+#define ALUGRID_VERTEX_PROJECTION
+
 // include all headers 
 #include "stlheaders.h"
 
 // defines IndexManagerType
 #include "indexstack.h"
 
+// defines VertexProjection Interface 
+#include "projectvertex.h"
+
 namespace ALUGridSpace {
 
 // the code needs this 
Index: duneinterface/gitter_dune_impl.h
===================================================================
--- duneinterface/gitter_dune_impl.h	(revision 1064)
+++ duneinterface/gitter_dune_impl.h	(revision 1173)
@@ -37,6 +37,7 @@
   enum IndexType { no_index = 0 , hierarchic_index = 1, leaf_index = 3 };
 
 protected:
+  // adaptation callback handler 
   AdaptRestrictProlongType * _arp;
 
   // call preCoarsening and postRefinement of arp
@@ -59,7 +60,7 @@
   virtual IteratorSTI < Gitter :: helement_STI > * leafIterator (const IteratorSTI < Gitter :: helement_STI > *) = 0 ;
 
 public:
-  GitterDuneBasis() : _arp(0) , maxlevel_(0) {}
+  GitterDuneBasis() : _arp(0), maxlevel_(0) {}
   
   virtual void backupIndices  (ostream & out);
   virtual void restoreIndices (istream & in );
@@ -111,11 +112,14 @@
 public:
 
   //! constructor creating grid from macro grid file 
-  inline GitterDuneImpl (const char *filename) : 
-    GitterBasisImpl ( filename ) {}
+  inline GitterDuneImpl (const char *filename, ProjectVertex* ppv = 0 ) 
+    : GitterBasisImpl (filename, ppv ) 
+  {}
   
   //! constructor creating empty grid 
-  inline GitterDuneImpl () : GitterBasisImpl () {}
+  inline GitterDuneImpl () 
+    : GitterBasisImpl () 
+  {}
 };
 
 
Index: duneinterface/gitter_dune_pll_impl.cc
===================================================================
--- duneinterface/gitter_dune_pll_impl.cc	(revision 1064)
+++ duneinterface/gitter_dune_pll_impl.cc	(revision 1173)
@@ -283,12 +283,14 @@
   for (iter.first (); ! iter.done () ; iter.next ()) 
   {
     HItemType & item = iter.item();
+
     // gather all data on slaves 
     if ( dataHandle.containsItem(item) ) 
     {
       // write marker that show data is transmitted 
       sendBuff.writeObject( transmittedData );
 
+      // reset read and write position
       osTmp.clear();
       // write data to fake buff to determine size of data package
       dataHandle.sendData(osTmp,item);
@@ -305,6 +307,7 @@
       sendBuff.writeObject( noData );
     }
   }
+
   delete a.first;
   delete a.second;      
 
@@ -336,14 +339,18 @@
     // read data marker 
     recvBuff.readObject(hasdata);
     
+    // reserve and get comm buffers 
     item.reserveBuffer( nl + 1 );
+
+    // get comm buffers 
     DataBufferType & data = item.commBuffer();
 
     // only gather master data once 
     if ( dataHandle.containsItem( item ) ) 
     {
       // pack master data 
-      BufferType & mData = data[nl]; 
+      BufferType & mData = data[ nl ]; 
+      // reset read and write position
       mData.clear();
         
       // write master data to fake buffer 
@@ -354,14 +361,17 @@
     if (hasdata != noData) 
     {
       // pack slave data to tmnp buffer 
-      BufferType & v = data[link]; 
-      v.clear();
+      BufferType & slaveBuff = data[link]; 
+      // reset read and write position
+      slaveBuff.clear();
 
       int dataSize; 
       recvBuff.readObject(dataSize);
-      recvBuff.readStream(v,dataSize);
+      // read dataSize bytes from recvBuff and write to slaveStream 
+      recvBuff.readStream(slaveBuff, dataSize);
     }
   }
+
   delete a.first;
   delete a.second;
 
@@ -400,6 +410,7 @@
   for (iter.first (); ! iter.done () ; iter.next ()) 
   {
     HItemType & item = iter.item();
+    // get comm buffer 
     DataBufferType & dataBuff = item.commBuffer();
     
     // scatter on master 
@@ -435,6 +446,7 @@
       }
     } 
   }
+
   delete a.first;
   delete a.second;     
 
@@ -695,6 +707,7 @@
         unpackOnSlaves(recvBuff,determType, edgeData, nOtherlinks, link );
       }
     }
+
   } // end second loop over vertices and edges 
 
   return ;
Index: duneinterface/gitter_dune_pll_impl.h
===================================================================
--- duneinterface/gitter_dune_pll_impl.h	(revision 1064)
+++ duneinterface/gitter_dune_pll_impl.h	(revision 1173)
@@ -28,8 +28,11 @@
   typedef GitterDuneImpl :: Objects  Objects;
 
   
-  GitterDunePll (const char * filename , MpAccessLocal &mp) 
-    : GitterBasisPll (filename,mp) , balanceGrid_ (false) 
+  GitterDunePll (const char * filename , 
+                 MpAccessLocal &mp, 
+                 ProjectVertex* ppv = 0 ) 
+    : GitterBasisPll (filename, mp, ppv) 
+    , balanceGrid_ (false) 
   {
 #ifndef NDEBUG
     __STATIC_myrank = mp.myrank(); 
@@ -38,6 +41,17 @@
     rebuildGhostCells();
   }
 
+  GitterDunePll (MpAccessLocal &mp) 
+    : GitterBasisPll ("", mp, 0) 
+    , balanceGrid_ (false) 
+  {
+#ifndef NDEBUG
+    __STATIC_myrank = mp.myrank(); 
+#endif
+    // if grid is created from backup, then restore ghost cells 
+    rebuildGhostCells();
+  }
+
   ~GitterDunePll () {
   }
 
@@ -103,6 +117,12 @@
     return containerPll().indexManager(codim);
   }
 
+  // return indexmanger 
+  size_t numMacroBndSegments () const 
+  {
+    return containerPll().numMacroBndSegments();
+  }
+
   // restore parallel grid from before
   virtual void duneRestore (const char*) ;
   // backup current grid status 
Index: duneinterface/gitter_dune_pll_mgb.cc
===================================================================
--- duneinterface/gitter_dune_pll_mgb.cc	(revision 1064)
+++ duneinterface/gitter_dune_pll_mgb.cc	(revision 1173)
@@ -62,8 +62,9 @@
   {
     if (_hbnd3Map.find (key) == _hbnd3Map.end ()) 
     {
+      ProjectVertex* ppv = NULL;
       hface3_GEO * face =  InsertUniqueHface3 (v).first ;
-      hbndseg3_GEO * hb3 = myBuilder ().insert_hbnd3 (face,twst,bt) ;
+      hbndseg3_GEO * hb3 = myBuilder ().insert_hbnd3 (face,twst, ppv, bt) ;
       _hbnd3Map [key] = hb3 ;
       return true ;
     }
@@ -92,8 +93,9 @@
   {
     if (_hbnd4Map.find (key) == _hbnd4Map.end ()) 
     {
+      ProjectVertex* ppv = NULL;
       hface4_GEO * face =  InsertUniqueHface4 (v).first ;
-      hbndseg4_GEO * hb4 = myBuilder ().insert_hbnd4 (face,twst,bt) ;
+      hbndseg4_GEO * hb4 = myBuilder ().insert_hbnd4 (face,twst, ppv, bt) ;
       _hbnd4Map [key] = hb4 ;
       return true ;
     }
@@ -359,30 +361,43 @@
 void DuneParallelGridMover :: initialize ()
 {
   {
-    for (BuilderIF :: vertexlist_t :: iterator i = myBuilder ()._vertexList.begin () ;
-      i != myBuilder ()._vertexList.end () ; myBuilder ()._vertexList.erase (i ++)) 
+    BuilderIF :: vertexlist_t& _vertexList = myBuilder ()._vertexList;
+    const BuilderIF :: vertexlist_t :: iterator _vertexListend  = _vertexList.end ();
+    for (BuilderIF :: vertexlist_t :: iterator i = _vertexList.begin () ;
+      i != _vertexListend ; _vertexList.erase (i ++)) 
         _vertexMap [(*i)->ident ()] = (*i) ;
   }
   {
-    for (BuilderIF :: hedge1list_t :: iterator i = myBuilder ()._hedge1List.begin () ;
-      i != myBuilder ()._hedge1List.end () ; myBuilder ()._hedge1List.erase (i ++)) {
+    BuilderIF :: hedge1list_t& _hedge1List = myBuilder ()._hedge1List;
+    const BuilderIF :: hedge1list_t :: iterator _hedge1Listend = _hedge1List.end ();
+    for (BuilderIF :: hedge1list_t :: iterator i = _hedge1List.begin () ;
+         i != _hedge1Listend ; _hedge1List.erase (i ++)) 
+    {
       long k = (*i)->myvertex (0)->ident (), l = (*i)->myvertex (1)->ident () ;
       _edgeMap [edgeKey_t (k < l ? k : l, k < l ? l : k)] = (*i) ;
     }
   }
   {
-    for (BuilderIF :: hface3list_t :: iterator i = myBuilder ()._hface3List.begin () ; i != myBuilder ()._hface3List.end () ;
-     myBuilder ()._hface3List.erase (i ++)) 
+    BuilderIF :: hface3list_t& _hface3List = myBuilder ()._hface3List;
+    const BuilderIF :: hface3list_t :: iterator _hface3Listend = _hface3List.end ();
+    for (BuilderIF :: hface3list_t :: iterator i = _hface3List.begin () ; 
+         i != _hface3Listend ; _hface3List.erase (i ++)) 
     {
       _face3Map [faceKey_t ((*i)->myvertex (0)->ident (),(*i)->myvertex (1)->ident (), (*i)->myvertex (2)->ident ())] = (*i) ;
     }
   }
   {
-    for (BuilderIF :: hface4list_t :: iterator i = myBuilder ()._hface4List.begin () ; i != myBuilder ()._hface4List.end () ; 
-      myBuilder ()._hface4List.erase (i ++)) _face4Map [faceKey_t ((*i)->myvertex (0)->ident (),(*i)->myvertex (1)->ident (),
-        (*i)->myvertex (2)->ident ())] = (*i) ;
+    BuilderIF :: hface4list_t& _hface4List = myBuilder ()._hface4List;
+    const BuilderIF :: hface4list_t :: iterator _hface4Listend = _hface4List.end ();
+    for (BuilderIF :: hface4list_t :: iterator i = _hface4List.begin () ; 
+         i != _hface4Listend ; _hface4List.erase (i ++)) 
+      _face4Map [faceKey_t ((*i)->myvertex (0)->ident (),(*i)->myvertex (1)->ident (), (*i)->myvertex (2)->ident ())] = (*i) ;
   }
-  { for (BuilderIF :: hbndseg4list_t :: iterator i = myBuilder ()._hbndseg4List.begin () ; i != myBuilder ()._hbndseg4List.end () ; myBuilder ()._hbndseg4List.erase (i++)) 
+  { 
+    BuilderIF :: hbndseg4list_t& _hbndseg4List = myBuilder ()._hbndseg4List;
+    const BuilderIF :: hbndseg4list_t :: iterator _hbndseg4Listend = _hbndseg4List.end ();
+    for (BuilderIF :: hbndseg4list_t :: iterator i = _hbndseg4List.begin () ; 
+         i != _hbndseg4Listend ; _hbndseg4List.erase (i++)) 
     {
       typedef Gitter :: Geometric :: hface4_GEO hface4_GEO;
       hface4_GEO * face = (*i)->myhface4 (0);
@@ -415,8 +430,10 @@
   }
   
   {
-    for (BuilderIF :: hbndseg3list_t :: iterator i = myBuilder ()._hbndseg3List.begin () ; i != myBuilder ()._hbndseg3List.end () ;
-        myBuilder ()._hbndseg3List.erase (i++)) 
+    BuilderIF :: hbndseg3list_t& _hbndseg3List = myBuilder ()._hbndseg3List; 
+    const BuilderIF :: hbndseg3list_t :: iterator _hbndseg3Listend = _hbndseg3List.end ();
+    for (BuilderIF :: hbndseg3list_t :: iterator i = _hbndseg3List.begin () ; 
+         i != _hbndseg3Listend ; _hbndseg3List.erase (i++)) 
     {
       typedef Gitter :: Geometric :: hface3_GEO hface3_GEO;
       hface3_GEO * face = (*i)->myhface3 (0);
@@ -435,7 +452,7 @@
         {
           // insert new internal storage 
           _hbnd3Int [key] = new Hbnd3IntStorage ( face , (*i)->twist (0), 
-                                                 gh , gpair.second ) ;
+                                                  gh , gpair.second ) ;
         }
         // until here
         else 
@@ -451,33 +468,44 @@
   }
 
   {
-    for (BuilderIF :: tetralist_t :: iterator i = myBuilder ()._tetraList.begin () ; i != myBuilder ()._tetraList.end () ; 
-      myBuilder ()._tetraList.erase (i++)) 
+    BuilderIF :: tetralist_t& _tetraList = myBuilder ()._tetraList; 
+    const BuilderIF :: tetralist_t :: iterator _tetraListend = _tetraList.end ();
+    for (BuilderIF :: tetralist_t :: iterator i = _tetraList.begin () ; 
+         i != _tetraListend ; _tetraList.erase (i++)) 
     {
       _tetraMap [elementKey_t ((*i)->myvertex (0)->ident (), (*i)->myvertex (1)->ident (), 
            (*i)->myvertex (2)->ident (), (*i)->myvertex (3)->ident ())] = (*i) ;
     } 
   }
   {
-    for (BuilderIF :: periodic3list_t :: iterator i = myBuilder ()._periodic3List.begin () ; i != myBuilder ()._periodic3List.end () ; 
-      myBuilder ()._periodic3List.erase (i++)) 
+    BuilderIF :: periodic3list_t& _periodic3List = myBuilder ()._periodic3List; 
+    const BuilderIF :: periodic3list_t :: iterator _periodic3Listend = _periodic3List.end ();
+    for (BuilderIF :: periodic3list_t :: iterator i = _periodic3List.begin () ; 
+         i != _periodic3Listend ; _periodic3List.erase (i++)) 
     {
       _periodic3Map [elementKey_t ((*i)->myvertex (0)->ident (), (*i)->myvertex (1)->ident (), 
            (*i)->myvertex (2)->ident (), -((*i)->myvertex (3)->ident ())-1)] = (*i) ;
     }
   }
   {
-    for (BuilderIF :: periodic4list_t :: iterator i = myBuilder ()._periodic4List.begin () ; i != myBuilder ()._periodic4List.end () ; 
-      myBuilder ()._periodic4List.erase (i++)) 
+    BuilderIF :: periodic4list_t& _periodic4List = myBuilder ()._periodic4List;
+    const BuilderIF :: periodic4list_t :: iterator _periodic4Listend = _periodic4List.end () ;
+    for (BuilderIF :: periodic4list_t :: iterator i = _periodic4List.begin () ; 
+         i != _periodic4Listend ; _periodic4List.erase (i++)) 
     {
       _periodic4Map [elementKey_t ((*i)->myvertex (0)->ident (), (*i)->myvertex (1)->ident (), 
            (*i)->myvertex (3)->ident (), -((*i)->myvertex (4)->ident ())-1)] = (*i) ;
     }
   }
   {
-    for (BuilderIF :: hexalist_t :: iterator i = myBuilder ()._hexaList.begin () ; i != myBuilder ()._hexaList.end () ; 
-      myBuilder ()._hexaList.erase (i++)) _hexaMap [elementKey_t ((*i)->myvertex (0)->ident (), (*i)->myvertex (1)->ident (), 
-                  (*i)->myvertex (3)->ident (), (*i)->myvertex (4)->ident ())] = (*i) ;
+    BuilderIF :: hexalist_t& _hexaList = myBuilder()._hexaList;
+    const BuilderIF :: hexalist_t :: iterator _hexaListend = _hexaList.end ();
+    for (BuilderIF :: hexalist_t :: iterator i = _hexaList.begin () ; 
+         i != _hexaListend ; _hexaList.erase (i++)) 
+    {
+      _hexaMap [elementKey_t ((*i)->myvertex (0)->ident (), (*i)->myvertex (1)->ident (), 
+                (*i)->myvertex (3)->ident (), (*i)->myvertex (4)->ident ())] = (*i) ;
+    }
   }
 
   // from constructor ParallelGridMover 
@@ -490,7 +518,8 @@
   toDelete.reserve( vecSize );
   
   {
-    for (elementMap_t :: iterator i = _hexaMap.begin () ; i != _hexaMap.end () ; i ++)
+    const elementMap_t :: iterator _hexaMapend = _hexaMap.end ();
+    for (elementMap_t :: iterator i = _hexaMap.begin () ; i != _hexaMapend ; ++i)
     {
       if (Gitter :: InternalElement ()(*((hexa_GEO *)(*i).second)).accessPllX ().erasable ()) 
       {
@@ -499,7 +528,8 @@
     }
   }
   {
-    for (elementMap_t :: iterator i = _tetraMap.begin () ; i != _tetraMap.end () ; i ++)
+    const elementMap_t :: iterator _tetraMapend = _tetraMap.end ();
+    for (elementMap_t :: iterator i = _tetraMap.begin () ; i != _tetraMapend ; ++i)
     {
       if (Gitter :: InternalElement ()(*((tetra_GEO *)(*i).second)).accessPllX ().erasable ()) 
       {
@@ -508,7 +538,8 @@
     }
   }
   {
-    for (elementMap_t :: iterator i = _periodic3Map.begin () ; i != _periodic3Map.end () ; i ++)
+    const elementMap_t :: iterator _periodic3Mapend = _periodic3Map.end ();
+    for (elementMap_t :: iterator i = _periodic3Map.begin () ; i != _periodic3Mapend ; ++i)
     {
       if (Gitter :: InternalElement ()(*((periodic3_GEO *)(*i).second)).accessPllX ().erasable ()) 
       {
@@ -517,7 +548,8 @@
     }
   }
   {
-    for (elementMap_t :: iterator i = _periodic4Map.begin () ; i != _periodic4Map.end () ; i ++)
+    const elementMap_t :: iterator _periodic4Mapend = _periodic4Map.end ();
+    for (elementMap_t :: iterator i = _periodic4Map.begin () ; i != _periodic4Mapend ; ++i)
     {
       if (Gitter :: InternalElement ()(*((periodic4_GEO *)(*i).second)).accessPllX ().erasable ()) 
       {
@@ -528,7 +560,8 @@
 
   // delete all elements 
   {
-    for (vector < elementKey_t > :: iterator i = toDelete.begin () ; i != toDelete.end () ; i ++ )
+    const vector < elementKey_t > :: iterator toDeleteend = toDelete.end (); 
+    for (vector < elementKey_t > :: iterator i = toDelete.begin () ; i != toDeleteend ; ++i )
       removeElement (*i) ;
   }
 
@@ -552,82 +585,114 @@
 // overloaded, because here we use the new insertInternal method 
 void DuneParallelGridMover :: finalize ()
 {
-  {for (elementMap_t :: iterator i = _hexaMap.begin () ; i != _hexaMap.end () ; _hexaMap.erase (i++))
-    myBuilder ()._hexaList.push_back ((hexa_GEO *)(*i).second) ;
+  {
+    const elementMap_t :: iterator _hexaMapend = _hexaMap.end ();
+    for (elementMap_t :: iterator i = _hexaMap.begin () ; i != _hexaMapend ; _hexaMap.erase (i++))
+      myBuilder ()._hexaList.push_back ((hexa_GEO *)(*i).second) ;
   }
-  {for (elementMap_t :: iterator i = _tetraMap.begin () ; i != _tetraMap.end () ; _tetraMap.erase (i++))
-    myBuilder ()._tetraList.push_back ((tetra_GEO *)(*i).second) ;
+  {
+    const elementMap_t :: iterator _tetraMapend = _tetraMap.end ();
+    for (elementMap_t :: iterator i = _tetraMap.begin () ; i != _tetraMapend ; _tetraMap.erase (i++))
+      myBuilder ()._tetraList.push_back ((tetra_GEO *)(*i).second) ;
   }
-  {for (elementMap_t :: iterator i = _periodic3Map.begin () ; i != _periodic3Map.end () ; _periodic3Map.erase (i++))
-    myBuilder ()._periodic3List.push_back ((periodic3_GEO *)(*i).second) ;
+  {
+    const elementMap_t :: iterator _periodic3Mapend = _periodic3Map.end ();
+    for (elementMap_t :: iterator i = _periodic3Map.begin () ; i != _periodic3Mapend ; _periodic3Map.erase (i++))
+      myBuilder ()._periodic3List.push_back ((periodic3_GEO *)(*i).second) ;
   }
   
-  {for (elementMap_t :: iterator i = _periodic4Map.begin () ; i != _periodic4Map.end () ; _periodic4Map.erase (i++))
-    myBuilder ()._periodic4List.push_back ((periodic4_GEO *)(*i).second) ;
+  {
+    const elementMap_t :: iterator _periodic4Mapend =  _periodic4Map.end ();
+    for (elementMap_t :: iterator i = _periodic4Map.begin () ; i != _periodic4Mapend ; _periodic4Map.erase (i++))
+      myBuilder ()._periodic4List.push_back ((periodic4_GEO *)(*i).second) ;
   }
 
-  {for (faceMap_t :: iterator i = _hbnd4Map.begin () ; i != _hbnd4Map.end () ; )
-    if (((hbndseg4_GEO *)(*i).second)->myhface4 (0)->ref == 1) 
+  {
+    const faceMap_t :: iterator _hbnd4Mapend = _hbnd4Map.end ();
+    for (faceMap_t :: iterator i = _hbnd4Map.begin () ; i != _hbnd4Map.end () ; )
     {
-      delete (hbndseg4_GEO *)(*i).second ;
-      _hbnd4Map.erase (i++) ;
-    } else {
-      myBuilder ()._hbndseg4List.push_back ((hbndseg4_GEO *)(*i ++).second) ;
+      if (((hbndseg4_GEO *)(*i).second)->myhface4 (0)->ref == 1) 
+      {
+        delete (hbndseg4_GEO *)(*i).second ;
+        _hbnd4Map.erase (i++) ;
+      } 
+      else 
+      {
+        myBuilder ()._hbndseg4List.push_back ((hbndseg4_GEO *)(*i ++).second) ;
+      }
     }
   }
-  {for (faceMap_t :: iterator i = _hbnd3Map.begin () ; i != _hbnd3Map.end () ; )
-    if (((hbndseg3_GEO *)(*i).second)->myhface3 (0)->ref == 1) {
-      delete (hbndseg3_GEO *)(*i).second ;
-      _hbnd3Map.erase (i++) ;
-    } else {
-      myBuilder ()._hbndseg3List.push_back ((hbndseg3_GEO *)(*i ++).second) ;
+  {
+    const faceMap_t :: iterator _hbnd3Mapend = _hbnd3Map.end ();
+    for (faceMap_t :: iterator i = _hbnd3Map.begin () ; i != _hbnd3Map.end () ; )
+    {
+      if (((hbndseg3_GEO *)(*i).second)->myhface3 (0)->ref == 1) 
+      {
+        delete (hbndseg3_GEO *)(*i).second ;
+        _hbnd3Map.erase (i++) ;
+      } 
+      else 
+      {
+        myBuilder ()._hbndseg3List.push_back ((hbndseg3_GEO *)(*i ++).second) ;
+      }
     }
   }
   {
-    for (hbnd4intMap_t :: iterator i = _hbnd4Int.begin () ; i != _hbnd4Int.end () ; i ++) 
+    const hbnd4intMap_t :: iterator _hbnd4Intend = _hbnd4Int.end ();
+    for (hbnd4intMap_t :: iterator i = _hbnd4Int.begin () ; i != _hbnd4Intend ; ++i) 
     {
-      Hbnd4IntStorage & p = * ((*i).second) ;
-      if (p.first()->ref == 1) 
+      Hbnd4IntStorage* p = (*i).second;
+      if (p->first()->ref == 1) 
       {
         // get ghost info from storage and release pointer 
-        MacroGhostInfoHexa* ghInfo = p.release();
+        MacroGhostInfoHexa* ghInfo = p->release();
 
         hbndseg4_GEO * hb4 = myBuilder ().
-              insert_hbnd4 (p.first(),p.second(),Gitter :: hbndseg_STI :: closure, ghInfo );
+              insert_hbnd4 (p->first(), p->second(), NULL, // no projection  
+                  Gitter :: hbndseg_STI :: closure, ghInfo );
         myBuilder ()._hbndseg4List.push_back (hb4) ;
       }
-      delete (*i).second;
+      delete p; 
     } 
   }
 
   // here the internal boundary elements are created 
   {
-    for (hbnd3intMap_t :: iterator i = _hbnd3Int.begin () ; i != _hbnd3Int.end () ; i ++) 
+    const hbnd3intMap_t :: iterator _hbnd3Intend = _hbnd3Int.end ();
+    for (hbnd3intMap_t :: iterator i = _hbnd3Int.begin () ; i != _hbnd3Intend ; ++i ) 
     {
-      Hbnd3IntStorage & p = *((*i).second);
-      if (p.first()->ref == 1) 
+      Hbnd3IntStorage* p = (*i).second;
+      if (p->first()->ref == 1) 
       {
         // get ghost info from storage and release pointer 
-        MacroGhostInfoTetra* ghInfo = p.release();
+        MacroGhostInfoTetra* ghInfo = p->release();
 
-        hbndseg3_GEO * hb3 = myBuilder().insert_hbnd3( p.first(),p.second(),
+        hbndseg3_GEO * hb3 = myBuilder().insert_hbnd3( p->first(), p->second(), NULL, // no projection 
                           Gitter :: hbndseg_STI :: closure , ghInfo );
         myBuilder ()._hbndseg3List.push_back (hb3) ;
       }
-      delete (*i).second; 
+      delete p; 
     }
   }
-  {for (faceMap_t :: iterator i = _face4Map.begin () ; i != _face4Map.end () ; )
-    if (!((hface4_GEO *)(*i).second)->ref) {
-      delete (hface4_GEO *)(*i).second ;
-      _face4Map.erase (i++) ;
-    } else {
-      //assert (((hface4_GEO *)(*i).second)->ref == 2) ;
-      myBuilder ()._hface4List.push_back ((hface4_GEO *)(*i ++).second ) ;
+  {
+    const faceMap_t :: iterator _face4Mapend = _face4Map.end ();
+    for (faceMap_t :: iterator i = _face4Map.begin () ; i != _face4Mapend ; )
+    {
+      if (!((hface4_GEO *)(*i).second)->ref) 
+      {
+        delete (hface4_GEO *)(*i).second ;
+        _face4Map.erase (i++) ;
+      } 
+      else 
+      {
+        //assert (((hface4_GEO *)(*i).second)->ref == 2) ;
+        myBuilder ()._hface4List.push_back ((hface4_GEO *)(*i ++).second ) ;
+      }
     }
   }
   {
-    for (faceMap_t :: iterator i = _face3Map.begin () ; i != _face3Map.end () ; ) 
+    const faceMap_t :: iterator _face3Mapend = _face3Map.end () ;
+    for (faceMap_t :: iterator i = _face3Map.begin () ; i != _face3Mapend ; ) 
     {
       if (!((hface3_GEO *)(*i).second)->ref) 
       {
@@ -641,17 +706,24 @@
       }
     }
   }
-  {for (edgeMap_t :: iterator i = _edgeMap.begin () ; i != _edgeMap.end () ; )
-    if (!(*i).second->ref) {
-      delete (*i).second ;
-      _edgeMap.erase (i++) ;
-    } else {
-      assert ((*i).second->ref >= 1) ;
-      myBuilder ()._hedge1List.push_back ((*i ++).second) ;
+  {
+    const edgeMap_t :: iterator _edgeMapend = _edgeMap.end ();
+    for (edgeMap_t :: iterator i = _edgeMap.begin () ; i != _edgeMapend ; )
+    {
+      if (!(*i).second->ref) {
+        delete (*i).second ;
+        _edgeMap.erase (i++) ;
+      } 
+      else 
+      {
+        assert ((*i).second->ref >= 1) ;
+        myBuilder ()._hedge1List.push_back ((*i ++).second) ;
+      }
     }
   }
   {
-    for (vertexMap_t :: iterator i = _vertexMap.begin () ; i != _vertexMap.end () ; )
+    const vertexMap_t :: iterator _vertexMapend = _vertexMap.end ();
+    for (vertexMap_t :: iterator i = _vertexMap.begin () ; i != _vertexMapend ; )
     {
       if (!(*i).second->ref) 
       {
Index: parallel/metis.c
===================================================================
--- parallel/metis.c	(revision 1064)
+++ parallel/metis.c	(revision 1173)
@@ -1,38 +0,0 @@
-// (c) --
-#if defined METISTITLE || defined METIS_H 
-#define METIS_C_INCLUDED 
-#endif
-
-#ifndef METIS_C_INCLUDED
-#define METIS_C_INCLUDED
-
-#warning  -- Compiling parallel version without METIS !!!
-
-using namespace std;
-
-static const char metmess [] = 	"**INFO Due to license reasons the library METIS is\n"
-				"       not part of the ALUGrid library distribution. \n"
-				"       To use this feature get a copy of the METIS library \n"
-        "       (see http://www-users.cs.umn.edu/~karypis/metis/metis/ )\n"
-        "       and re-configure the ALUGrid library with the \n"
-        "       --with-metis=PATH_TO_METIS option, \n"
-        "       or choose another Graph partitioning method. \n"
-        "       Exiting program, bye! \n";
-
-// dummy METIS_PartGraphKway, when METIS library is missing 
-void METIS_PartGraphKway(int *,idxtype *,idxtype *,idxtype *,idxtype *,int *,int *,int *,int *,int *,idxtype *) {
-  cerr << "**ERROR The use of METIS_PartGraphKway is not supported, when the METIS library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << metmess << endl ;
-  exit(1); 
-  return ;
-}
-
-// dummy METIS_PartGraphRecursive, when METIS library is missing 
-void METIS_PartGraphRecursive(int *,idxtype *,idxtype *,idxtype *,idxtype *,int *,int *,int *,int *,int *,idxtype *) {
-  cerr << "**ERROR The use of METIS_PartGraphRecursive is not supported, when the METIS library is missing! " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << metmess << endl ;
-  exit(1);
-  return ;
-}
-
-#endif
Index: parallel/parmetis.c
===================================================================
--- parallel/parmetis.c	(revision 1064)
+++ parallel/parmetis.c	(revision 1173)
@@ -1,30 +0,0 @@
-// (c) --
-#ifndef __parmetis_h__
-
-#warning  -- Compiling parallel version without PARMETIS !!!
-
-#ifndef PARMETIS_C_INCLUDED
-#define PARMETIS_C_INCLUDED
-
-using namespace std; 
-
-static const char metmess [] = 	"**INFO Due to license reasons the library METIS is\n"
-				"       not part of the ALUGrid library distribution. \n"
-				"       To use this feature get a copy of the METIS library \n"
-        "       (see http://www-users.cs.umn.edu/~karypis/metis/metis/ )\n"
-        "       and re-configure the ALUGrid library with the \n"
-        "       --with-metis=PATH_TO_METIS option, \n"
-        "       or choose another Graph partitioning method. \n"
-        "       Exiting program, bye! \n";
-
-// dummy METIS_PartGraphKway, when METIS library is missing 
-void ParMETIS_V3_PartKway(int *,idxtype *,idxtype *,idxtype *,idxtype *,int *,int *,int *,int *,int *,idxtype *, MPI_Comm *) 
-{
-  cerr << "**ERROR The use of ParMETIS_V3_PartKway is not supported, when the METIS library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << metmess << endl ;
-  exit(1); 
-  return ;
-}
-
-#endif
-#endif
Index: parallel/party_lib.c
===================================================================
--- parallel/party_lib.c	(revision 1064)
+++ parallel/party_lib.c	(revision 1173)
@@ -1,74 +0,0 @@
-// (c) --
-#ifndef PARTY_LIB_C_INCLUDED
-#define PARTY_LIB_C_INCLUDED
-
-#warning  -- Compiling parallel version without PARTY_LIB !!! 
-
-using namespace std; 
-
-static const char parmess [] = 	"**INFO Due to license reasons the library PARTY is\n"
-				"       not part of the ALUGrid library distribution. \n"
-				"       To use this feature get a copy of the PARTY library \n"
-        "       (see http://wwwcs.upb.de/fachbereich/AG/monien/RESEARCH/PART/party.html)\n"
-        "       and re-configure the ALUGrid library with the \n"
-        "       --with-party=PATH_TO_PARTY option, \n"
-        "       or choose another Graph partitioning method. \n"
-        "       Exiting program, bye! \n";
-
-// dummy method, when library missing        
-int global_lin (int,float *,int,int *) {
-  cerr << "**ERROR The use of global_lin is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << parmess << endl ;
-  exit(1);
-  return 0 ;
-}
-
-// dummy method, when library missing        
-int global_sca(int,float *,int,int *) {
-  cerr << "**ERROR The use of global_sca is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << parmess << endl ;
-  exit(1);
-  return 0 ;
-}
-
-// dummy method, when library missing        
-int global_ran(int,float *,int,int *) {
-  cerr << "**ERROR The use of global_ran is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << parmess << endl ;
-  exit(1);
-  return 0 ;
-}
-
-// dummy method, when library missing        
-int global_gbf (int,float *,int *,int *,int *,int,int *) {
-  cerr << "**ERROR The use of global_gbf is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << parmess << endl ;
-  exit(1);
-  return 0 ;
-}
-
-// dummy method, when library missing        
-int global_gcf (int,float *,int *,int *,int *,int,int *) {
-  cerr << "**ERROR The use of global_gcf is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << parmess << endl ;
-  exit(1);
-  return 0 ;
-}
-
-// dummy method, when library missing        
-int local_kl (int,float *,int *,int *,int *,int, int *,int) {
-  cerr << "**ERROR The use of local_kl is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << parmess << endl ;
-  exit(1);
-  return 0 ;
-}
-
-// dummy method, when library missing        
-int local_hs (int n, float *vertex_w, int *edge_p, int *edge, int *edge_w,int p, int *part,int Output) {
-  cerr << "**ERROR The use of local_hs is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
-  cerr << parmess << endl ;
-  exit(1);
-  return 0 ;
-}
-
-#endif
Index: parallel/metis.h
===================================================================
--- parallel/metis.h	(revision 1064)
+++ parallel/metis.h	(revision 1173)
@@ -1,14 +0,0 @@
-// (c) --
-#if defined METISTITLE || defined METIS_H 
-#define METIS_H_INCLUDED
-#endif
-
-#ifndef METIS_H_INCLUDED
-#define METIS_H_INCLUDED
-
-typedef int idxtype ;
-
-void METIS_PartGraphKway(int *,idxtype *,idxtype *,idxtype *,idxtype *,int *,int *,int *,int *,int *,idxtype *);
-void METIS_PartGraphRecursive(int *,idxtype *,idxtype *,idxtype *,idxtype *,int *,int *,int *,int *,int *,idxtype *);
-
-#endif
Index: parallel/parmetis.h
===================================================================
--- parallel/parmetis.h	(revision 1064)
+++ parallel/parmetis.h	(revision 1173)
@@ -1,12 +0,0 @@
-// (c) --
-#ifndef __parmetis_h__
-
-#ifndef PARMETIS_H_INCLUDED
-#define PARMETIS_H_INCLUDED
-
-typedef int idxtype ;
-
-void ParMETIS_V3_PartKway(int *,idxtype *,idxtype *,idxtype *,idxtype *,int *,int *,int *,int *,int *,idxtype *, MPI_Comm *);
-
-#endif
-#endif
Index: parallel/party_lib.h
===================================================================
--- parallel/party_lib.h	(revision 1064)
+++ parallel/party_lib.h	(revision 1173)
@@ -1,41 +0,0 @@
-  // (c) --
-	// Diese Datei enth"alt nur inaktive Prozeduren, die der
-	// Aufrufkonvention der Partitionierungsbibliothek PARTY
-	// folgen. Dadurch wird die testweise "Ubersetzung des
-	// Programms m"oglich, wobei aber die Funktionalit"at der
-	// Graphenpartitionierungsverfahren aus PARTY nicht zur
-	// Verf"ugung steht.
-	// (c) PARTY ist urheberrechtliches Eigentum der 
-	// Universit"at Paderborn und kann zu wissenschaftlichen
-	// Zwecken von dort kostenlos bezogen werden.
-	//
-	// http://www.uni-paderborn.de/fachbereich/AG/monien/RESEARCH/PART/party.html
-	//
-	// Ansprechpartner:
-	// Robert Preis 	<preis@hni.uni-paderborn.de>
-	// 
-	// **********************************************************
-	// *
-	// *  PARTY PARTITIONING LIBRARY            party_lib.h
-	// *
-	// *  Robert Preis
-	// *  HEINZ NIXDORF INSTITUT
-	// *  Universit\"at Paderborn, Germany
-	// *  preis@hni.uni-paderborn.de
-	// *
-	// **********************************************************
-
-#ifndef PARTY_LIB_H_INCLUDED
-#define PARTY_LIB_H_INCLUDED
-
-int global_lin (int,float *,int,float,int *);
-int global_sca (int,float *,int,float,int *);
-int global_ran (int,float *,int,float,int *);
-
-int global_gfc (int,float *,int *,int *,int *,int,int *);
-int global_gbf (int,float *,int *,int *,int *,int,int *);
-
-int local_kl (int,float *,int *,int *,int *,int,int *,int);
-int local_hs (int n, float *vertex_w, int *edge_p, int *edge, int *edge_w,int p, int *part,int Output);
-
-#endif
Index: parallel/alumetis.hh
===================================================================
--- parallel/alumetis.hh	(revision 0)
+++ parallel/alumetis.hh	(revision 1173)
@@ -0,0 +1,60 @@
+#ifndef METIS_H_INCLUDED
+#define METIS_H_INCLUDED
+
+#if HAVE_METIS 
+// cover metis-4.0 bug   
+#define __log2 __METIS__log2
+extern "C" {
+  #include <metis.h>
+}
+#else 
+static const char metmess [] =  "**INFO Due to license reasons the library METIS is\n"
+        "       not part of the ALUGrid library distribution. \n"
+        "       To use this feature get a copy of the METIS library \n"
+        "       (see http://www-users.cs.umn.edu/~karypis/metis/metis/ )\n"
+        "       and re-configure the ALUGrid library with the \n"
+        "       --with-metis=PATH_TO_METIS option, \n"
+        "       or choose another Graph partitioning method. \n"
+        "       Exiting program, bye! \n";
+#endif
+
+typedef int idxtype ;
+
+inline void CALL_METIS_PartGraphKway(int *n, idxtype *edge_p, idxtype *edge,
+                idxtype * vertex_wInt, idxtype *edge_w,
+                int *wgtflag, int *numflag, int *npart,
+                int *options, int *edgecut, idxtype *neu)
+{
+#if HAVE_METIS  
+  // call metis function 
+  :: METIS_PartGraphKway (n, edge_p, edge, 
+                          vertex_wInt, edge_w,
+                          wgtflag,  numflag, npart, 
+                          options, edgecut, neu) ;
+#else 
+  std::cerr << "**ERROR The use of METIS_PartGraphKway is not supported, when the METIS library is missing!  in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << metmess << std::endl ;
+  exit(1);
+#endif
+  return ;
+}
+
+inline void CALL_METIS_PartGraphRecursive(int *n, idxtype *edge_p, idxtype *edge,
+                idxtype * vertex_wInt, idxtype *edge_w,
+                int *wgtflag, int *numflag, int *npart,
+                int *options, int *edgecut, idxtype *neu)
+{
+#if HAVE_METIS  
+  // call metis function 
+  :: METIS_PartGraphRecursive(n, edge_p, edge, 
+                          vertex_wInt, edge_w,
+                          wgtflag,  numflag, npart, 
+                          options, edgecut, neu) ;
+#else 
+  std::cerr << "**ERROR The use of METIS_PartGraphRecursive is not supported, when the METIS library is missing!  in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << metmess << std::endl ;
+  exit(1);
+#endif
+  return ;
+}
+#endif

Property changes on: parallel/alumetis.hh
___________________________________________________________________
Added: svn:keywords
   + Author Date Id Revision
Added: svn:eol-style
   + native

Index: parallel/gitter_hexa_top_pll.h
===================================================================
--- parallel/gitter_hexa_top_pll.h	(revision 1064)
+++ parallel/gitter_hexa_top_pll.h	(revision 1173)
@@ -16,7 +16,7 @@
     typedef typename A :: bnd_t     bnd_t ;
   public :
     inline Hbnd4PllExternal (myhface4_t *, int,ProjectVertex *, 
-                  const bnd_t bt, IndexManagerType & , Gitter * ) ;
+                  const bnd_t bt, IndexManagerType &) ;
     inline ~Hbnd4PllExternal () ;
     ElementPllXIF_t & accessPllX () throw (Parallel :: AccessPllException) ;
     const ElementPllXIF_t & accessPllX () const throw (Parallel :: AccessPllException) ;
@@ -45,7 +45,7 @@
         typedef typename A :: balrule_t  balrule_t ;
         typedef typename A :: bnd_t     bnd_t ;
 
-        inline HbndPll (myhface4_t *, int, ProjectVertex *, Gitter *) ;
+        inline HbndPll (myhface4_t *, int, ProjectVertex *) ;
        ~HbndPll () {}
         virtual bool bndNotifyBalance (balrule_t,int) ;
         virtual bool lockedAgainstCoarsening () const ;
@@ -102,11 +102,11 @@
       public :
         HbndPllMacro (myhface4_t *,int, ProjectVertex *,
                       const bnd_t bt , IndexManagerType & im, 
-                      Gitter * , BuilderIF & ,
+                      BuilderIF & ,
                       MacroGhostInfoHexa* ) ;
         HbndPllMacro (myhface4_t *,int, ProjectVertex *,
                       const bnd_t bt , IndexManagerType & im, 
-                      Gitter * , BuilderIF & );
+                      BuilderIF & );
 
        ~HbndPllMacro () ;
         ElementPllXIF_t & accessPllX () throw (Parallel :: AccessPllException) ;
@@ -137,8 +137,8 @@
 
 template < class A, class MX > inline Hbnd4PllExternal < A, MX > :: 
 Hbnd4PllExternal (myhface4_t * f, int t, ProjectVertex *ppv, const bnd_t bt , 
-    IndexManagerType & im, Gitter * grd ) 
-  : Hbnd4Top < A > (0,f,t,ppv,bt,im,grd), _mxt (new MX (*this)) 
+    IndexManagerType & im) 
+  : Hbnd4Top < A > (0,f,t,ppv,bt,im), _mxt (new MX (*this)) 
 {
   this->restoreFollowFace () ;
   return ;
@@ -167,7 +167,7 @@
 }
 
 template < class A, class X, class MX > inline Hbnd4PllInternal < A, X, MX > :: HbndPll :: 
-HbndPll (myhface4_t * f, int t, ProjectVertex *ppv, Gitter * grd) : A (f,t,ppv,grd), _ext (*this) , _ghostPair((helement_STI *) 0 ,-1) {
+HbndPll (myhface4_t * f, int t, ProjectVertex *ppv) : A (f,t,ppv), _ext (*this) , _ghostPair((helement_STI *) 0 ,-1) {
   return ;
 }
 
@@ -332,10 +332,10 @@
   
 template < class A, class X, class MX > Hbnd4PllInternal < A, X, MX > :: 
 HbndPllMacro :: HbndPllMacro (myhface4_t * f, int t, ProjectVertex *ppv,
-              const bnd_t bt, IndexManagerType & im , 
-              Gitter * grd , BuilderIF & mgb,
+              const bnd_t bt, 
+              IndexManagerType & im, BuilderIF & mgb,
               MacroGhostInfoHexa* ghInfo ) 
-: Hbnd4Top < micro_t > (0,f,t,ppv,bt,im,grd)
+: Hbnd4Top < micro_t > (0,f,t,ppv,bt,im)
 , _mxt (0) 
 , _mgb(mgb) 
 , _gm(  new MacroGhostHexa( _mgb , ghInfo, f ) )  
@@ -351,9 +351,8 @@
 
 template < class A, class X, class MX > Hbnd4PllInternal < A, X, MX > :: 
 HbndPllMacro :: HbndPllMacro (myhface4_t * f, int t, ProjectVertex *ppv,
-              const bnd_t bt, IndexManagerType & im , 
-              Gitter * grd , BuilderIF & mgb)
-: Hbnd4Top < micro_t > (0,f,t,ppv,bt,im,grd)
+              const bnd_t bt, IndexManagerType & im, BuilderIF & mgb)
+: Hbnd4Top < micro_t > (0,f,t,ppv,bt,im)
 , _mxt (new MX (*this))
 , _mgb(mgb) 
 , _gm(0)  
Index: parallel/gitter_pll_idn.cc
===================================================================
--- parallel/gitter_pll_idn.cc	(revision 1064)
+++ parallel/gitter_pll_idn.cc	(revision 1173)
@@ -179,7 +179,8 @@
   return s ;
 }
 
-void GitterPll :: MacroGitterPll :: vertexLinkageEstimate (MpAccessLocal & c) {
+void GitterPll :: MacroGitterPll :: vertexLinkageEstimate (MpAccessLocal & c) 
+{
   typedef map < int, AccessIterator < vertex_STI > :: Handle, less < int > > map_t ;
   map_t map ;
   const int np = c.psize (), me = c.myrank () ;
Index: parallel/aluparmetis.hh
===================================================================
--- parallel/aluparmetis.hh	(revision 0)
+++ parallel/aluparmetis.hh	(revision 1173)
@@ -0,0 +1,59 @@
+#ifndef PARMETIS_H_INCLUDED
+#define PARMETIS_H_INCLUDED
+
+#if HAVE_PARMETIS
+// partitioning libs 
+// ParMETIS if not found here then dummy version is included 
+extern "C" {
+  #include <parmetis.h>
+}
+#else  
+static const char parmetmess [] =
+        "**INFO Due to license reasons the library ParMETIS is\n"
+        "       not part of the ALUGrid library distribution. \n"
+        "       To use this feature get a copy of the ParMETIS library \n"
+        "       (see http://www-users.cs.umn.edu/~karypis/metis/metis/ )\n"
+        "       and re-configure the ALUGrid library with the \n"
+        "       --with-parmetis=PATH_TO_ParMETIS option, \n"
+        "       or choose another Graph partitioning method. \n"
+        "       Exiting program, bye! \n";
+typedef int idxtype ;
+#endif
+
+
+inline void CALL_ParMETIS_V3_PartKway(
+             idxtype *vtxdist, idxtype *xadj, idxtype *adjncy, idxtype *vwgt,
+             idxtype *adjwgt, int *wgtflag, int *numflag, int *ncon, int *nparts,
+             float *tpwgts, float *ubvec, int *options, int *edgecut, idxtype *part,
+             MPI_Comm *comm)
+{
+#if HAVE_PARMETIS
+   :: ParMETIS_V3_PartKway(vtxdist, xadj, adjncy, vwgt, adjwgt,
+                           wgtflag, numflag, ncon, nparts, tpwgts,
+                           ubvec, options, edgecut, part, comm ) ;
+#else 
+  std::cerr << "**ERROR The use of ParMETIS is not supported, when the ParMETIS library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmetmess << std::endl ;
+  exit(1);
+#endif
+  return ;
+}
+
+inline void CALL_ParMETIS_V3_AdaptiveRepart(
+       idxtype *vtxdist, idxtype *xadj, idxtype *adjncy, idxtype *vwgt,
+       idxtype *vsize, idxtype *adjwgt, int *wgtflag, int *numflag, int *ncon,
+       int *nparts, float *tpwgts, float *ubvec, float *ipc2redist,
+       int *options, int *edgecut, idxtype *part, MPI_Comm *comm)
+{
+#if HAVE_PARMETIS
+  :: ParMETIS_V3_AdaptiveRepart(vtxdist, xadj, adjncy, vwgt, vsize, adjwgt,
+                                wgtflag, numflag, ncon, nparts, tpwgts,
+                                ubvec, ipc2redist, options, edgecut, part, comm ) ;
+#else 
+  std::cerr << "**ERROR The use of ParMETIS is not supported, when the ParMETIS library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmetmess << std::endl ;
+  exit(1);
+#endif
+  return ;
+}
+#endif

Property changes on: parallel/aluparmetis.hh
___________________________________________________________________
Added: svn:keywords
   + Author Date Id Revision
Added: svn:eol-style
   + native

Index: parallel/mpAccess.h
===================================================================
--- parallel/mpAccess.h	(revision 1064)
+++ parallel/mpAccess.h	(revision 1173)
@@ -6,6 +6,15 @@
 
 class MpAccessGlobal {
   public :
+    class CommIF
+    {
+    protected:
+      CommIF () {}
+    public:
+      virtual ~CommIF() {}
+      virtual CommIF* clone () const = 0;
+    };
+
     inline virtual ~MpAccessGlobal () ;
     virtual int psize () const = 0 ;
     virtual int myrank () const = 0 ;
@@ -30,6 +39,9 @@
     virtual vector < vector < int > > gcollect (const vector < int > &) const = 0 ;
     virtual vector < vector < double > > gcollect (const vector < double > &) const = 0 ;
     virtual vector < ObjectStream > gcollect (const ObjectStream &) const = 0 ;
+
+    //! return address of communicator (not optimal but avoid explicit MPI types here)
+    virtual const CommIF* communicator() const = 0;
 } ;
 
 class MpAccessLocal : public MpAccessGlobal {
Index: parallel/aluparty_lib.hh
===================================================================
--- parallel/aluparty_lib.hh	(revision 0)
+++ parallel/aluparty_lib.hh	(revision 1173)
@@ -0,0 +1,134 @@
+  // (c) --
+	// Diese Datei enth"alt nur inaktive Prozeduren, die der
+	// Aufrufkonvention der Partitionierungsbibliothek PARTY
+	// folgen. Dadurch wird die testweise "Ubersetzung des
+	// Programms m"oglich, wobei aber die Funktionalit"at der
+	// Graphenpartitionierungsverfahren aus PARTY nicht zur
+	// Verf"ugung steht.
+	// (c) PARTY ist urheberrechtliches Eigentum der 
+	// Universit"at Paderborn und kann zu wissenschaftlichen
+	// Zwecken von dort kostenlos bezogen werden.
+	//
+	// http://www.uni-paderborn.de/fachbereich/AG/monien/RESEARCH/PART/party.html
+	//
+	// Ansprechpartner:
+	// Robert Preis 	<preis@hni.uni-paderborn.de>
+	// 
+	// **********************************************************
+	// *
+	// *  PARTY PARTITIONING LIBRARY            party_lib.h
+	// *
+	// *  Robert Preis
+	// *  HEINZ NIXDORF INSTITUT
+	// *  Universit\"at Paderborn, Germany
+	// *  preis@hni.uni-paderborn.de
+	// *
+	// **********************************************************
+
+#ifndef PARTY_LIB_H_INCLUDED
+#define PARTY_LIB_H_INCLUDED
+
+#if HAVE_PARTY 
+extern "C" {
+  // include PARTY lib header 
+  #include <party_lib.h>
+}
+#else 
+static const char parmess [] =  "**INFO Due to license reasons the library PARTY is\n"
+        "       not part of the ALUGrid library distribution. \n"
+        "       To use this feature get a copy of the PARTY library \n"
+        "       (see http://wwwcs.upb.de/fachbereich/AG/monien/RESEARCH/PART/party.html)\n"
+        "       and re-configure the ALUGrid library with the \n"
+        "       --with-party=PATH_TO_PARTY option, \n"
+        "       or choose another Graph partitioning method. \n"
+        "       Exiting program, bye! \n";
+#endif
+
+inline int CALL_global_lin (int nel, float *vertex_w, int np, int *neu)
+{
+#if HAVE_PARTY 
+  return :: global_lin (nel, vertex_w, np, neu) ;
+#else
+  std::cerr << "**ERROR The use of global_lin is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmess << std::endl ;
+  exit(1); 
+  return 0 ;
+#endif
+}
+
+inline int CALL_global_sca (int nel, float *vertex_w, int np, int *neu)
+{
+#if HAVE_PARTY 
+  return :: global_sca (nel, vertex_w, np, neu) ;
+#else
+  std::cerr << "**ERROR The use of global_sca is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmess << std::endl ;
+  exit(1); 
+  return 0 ;
+#endif
+}
+
+inline int CALL_global_ran (int nel, float *vertex_w, int np, int *neu)
+{
+#if HAVE_PARTY 
+  return :: global_ran (nel, vertex_w, np, neu) ;
+#else
+  std::cerr << "**ERROR The use of global_ran is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmess << std::endl ;
+  exit(1); 
+  return 0 ;
+#endif
+}
+
+inline int CALL_global_gbf (int nel, float *vertex_w, int *edge_p,
+                            int *edge, int *edge_w, int np, int *neu)
+{
+#if HAVE_PARTY 
+  return :: global_gbf (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
+#else
+  std::cerr << "**ERROR The use of global_gbf is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmess << std::endl ;
+  exit(1); 
+  return 0 ;
+#endif
+}
+
+inline int CALL_global_gcf (int nel, float *vertex_w, int *edge_p,
+                            int *edge, int *edge_w, int np, int *neu)
+{
+#if HAVE_PARTY 
+  return :: global_gcf (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
+#else
+  std::cerr << "**ERROR The use of global_gcf is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmess << std::endl ;
+  exit(1); 
+  return 0 ;
+#endif
+}
+
+inline int CALL_local_kl (int nel, float *vertex_w, int *edge_p, 
+                          int *edge, int *edge_w, int np, int * neu, int output)
+{
+#if HAVE_PARTY 
+  return :: local_kl (nel, vertex_w, edge_p, edge, edge_w, np,  neu, output) ;
+#else
+  std::cerr << "**ERROR The use of local_kl is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmess << std::endl ;
+  exit(1); 
+  return 0 ;
+#endif
+}
+
+inline int CALL_local_hs (int nel, float *vertex_w, int *edge_p, 
+                          int *edge, int *edge_w, int np, int * neu, int output)
+{
+#if HAVE_PARTY 
+  return :: local_hs (nel, vertex_w, edge_p, edge, edge_w, np,  neu, output) ;
+#else
+  std::cerr << "**ERROR The use of local_hs is not supported, when the PARTY library is missing! in: " << __FILE__ << " line: " << __LINE__ << "\n";
+  std::cerr << parmess << std::endl ;
+  exit(1); 
+  return 0 ;
+#endif
+}
+#endif

Property changes on: parallel/aluparty_lib.hh
___________________________________________________________________
Added: svn:keywords
   + Author Date Id Revision
Added: svn:eol-style
   + native

Index: parallel/mpAccess_MPI.cc
===================================================================
--- parallel/mpAccess_MPI.cc	(revision 1064)
+++ parallel/mpAccess_MPI.cc	(revision 1173)
@@ -2,6 +2,83 @@
 
 #include "mpAccess_MPI.h"
 
+#ifndef NDEBUG
+#define MY_INT_TEST int test =
+#else
+#define MY_INT_TEST
+#endif
+
+MPI_Comm getMPICommunicator(const MpAccessMPI :: CommIF* mpiCommPtr) 
+{
+  typedef MpAccessMPI :: Comm< MPI_Comm > MyComm;
+  return static_cast<const MyComm&> (*mpiCommPtr);
+}
+
+template <>
+MpAccessMPI :: Comm< MPI_Comm > :: Comm( MPI_Comm mpicomm ) 
+{
+  // duplicate mpi communicator 
+  MY_INT_TEST MPI_Comm_dup ( mpicomm, & _mpiComm ) ;
+  assert (test == MPI_SUCCESS) ;
+}
+
+template <>
+MpAccessMPI :: Comm< MPI_Comm > :: ~Comm( ) 
+{
+  // free mpi communicator 
+  MY_INT_TEST MPI_Comm_free (&_mpiComm) ;
+  assert (test == MPI_SUCCESS) ;
+}
+
+// workarround for old member variable 
+#define _mpiComm (getMPICommunicator(_mpiCommPtr))
+
+int MpAccessMPI :: getSize()
+{
+  // get size from MPI 
+  int size = 0; 
+  MY_INT_TEST MPI_Comm_size ( _mpiComm, & size );
+  assert (test == MPI_SUCCESS) ;
+  return size;
+}
+
+int MpAccessMPI :: getRank()
+{
+  // get rank from MPI 
+  int rank = -1;
+  MY_INT_TEST MPI_Comm_rank ( _mpiComm, & rank );
+  assert (test == MPI_SUCCESS) ;
+  return rank;
+}
+
+MpAccessMPI :: MpAccessMPI (const MpAccessMPI & a)
+: _mpiCommPtr( a._mpiCommPtr->clone() ),
+  _psize( getSize() ) , _myrank( getRank() )
+{
+}
+
+MpAccessMPI :: ~MpAccessMPI ()
+{
+  delete _mpiCommPtr;
+  _mpiCommPtr = 0;
+}
+
+int MpAccessMPI :: barrier () const {
+    return MPI_SUCCESS == MPI_Barrier (_mpiComm) ? psize () : 0 ;
+}
+
+int MpAccessMPI :: mpi_allgather (int * i, int si, int * o, int so) const {
+    return MPI_Allgather (i, si, MPI_INT, o, so, MPI_INT, _mpiComm) ;
+}
+
+int MpAccessMPI :: mpi_allgather (char * i, int si, char * o, int so) const {
+    return MPI_Allgather (i, si, MPI_BYTE, o, so, MPI_BYTE, _mpiComm) ;
+}
+
+int MpAccessMPI :: mpi_allgather (double * i, int si, double * o, int so) const {
+    return MPI_Allgather (i, si, MPI_DOUBLE, o, so, MPI_DOUBLE, _mpiComm) ;
+}
+
 template < class A > vector < vector < A > > 
 doGcollectV (const vector < A > & in, MPI_Datatype mpiType, MPI_Comm comm) 
 {
@@ -522,3 +599,4 @@
   }
   return ;
 }
+#undef _mpiComm
Index: parallel/mpAccess_MPI.h
===================================================================
--- parallel/mpAccess_MPI.h	(revision 1064)
+++ parallel/mpAccess_MPI.h	(revision 1173)
@@ -6,124 +6,114 @@
 
 class MpAccessMPI : public MpAccessLocal 
 {
-    MPI_Comm _mpiComm ;
-    
-    inline int mpi_allgather (int *, int , int *, int) const ;
-    inline int mpi_allgather (char *, int, char *, int) const ;
-    inline int mpi_allgather (double *, int, double *, int ) const ;
-    public :
-      inline  MpAccessMPI (MPI_Comm) ;
-      inline  MpAccessMPI (const MpAccessMPI &) ;
-      inline ~MpAccessMPI () ;
-      inline int psize () const ;
-      inline int myrank () const ;
-      inline int barrier () const ;
-      int gmax (int) const ;
-      int gmin (int) const ;
-      int gsum (int) const ;
-      long gmax (long) const ;
-      long gmin (long) const ;
-      long gsum (long) const ;
-      double gmax (double) const ;
-      double gmin (double) const ;
-      double gsum (double) const ;
-      void gmax (double*,int,double*) const ;
-      void gmin (double*,int,double*) const ;
-      void gsum (double*,int,double*) const ;
-      pair<double,double> gmax (pair<double,double>) const ;
-      pair<double,double> gmin (pair<double,double>) const ;
-      pair<double,double> gsum (pair<double,double>) const ;
-      vector < int > gcollect (int) const ;
-      vector < double > gcollect (double) const ;
-      vector < vector < int > > gcollect (const vector < int > &) const ;
-      vector < vector < double > > gcollect (const vector < double > &) const ;
-      vector < ObjectStream > gcollect (const ObjectStream &) const ;
-      vector < vector < int > > exchange (const vector < vector < int > > &) const ;
-      vector < vector < double > > exchange (const vector < vector < double > > &) const ;
-      vector < vector < char > > exchange (const vector < vector < char > > &) const ;
-      
-      vector < ObjectStream > exchange (const vector < ObjectStream > &) const ;
+public:
+  typedef MpAccessGlobal :: CommIF CommIF;
 
-      // symectric exchange with same buffer size 
-      void exchange (const vector < ObjectStream > & in,
-                     vector< ObjectStream > & out) const;
-        
-} ;
+  template <class MPICommunicator>
+  class Comm : public CommIF
+  {
+    // no copying or assigning
+    Comm( const Comm& );
+    Comm& operator= ( const Comm& );
+    // we don't want MPI types here to avoid include of mpi.h 
+    mutable MPICommunicator _mpiComm;
+  public:  
+    // constructor duplicating mpi communicator
+    Comm( MPICommunicator );
+    // destructor freeing mpi communicator 
+    ~Comm();
+    // conversion operator to MPI_Comm 
+    operator MPICommunicator () const { return _mpiComm; }
 
+    //! return copy of this object  
+    virtual CommIF* clone() const { return new Comm< MPICommunicator > ( _mpiComm ); }
+  };
 
-	//
-	//    #    #    #  #          #    #    #  ######
-	//    #    ##   #  #          #    ##   #  #
-	//    #    # #  #  #          #    # #  #  #####
-	//    #    #  # #  #          #    #  # #  #
-	//    #    #   ##  #          #    #   ##  #
-	//    #    #    #  ######     #    #    #  ######
-	//
-#ifndef NDEBUG
-#define MY_INT_TEST int test =
-#else
-#define MY_INT_TEST
-#endif
+protected:  
+  // class holding the MPI communicator 
+  const CommIF* _mpiCommPtr;
+  // number of processors
+  const int _psize; 
+  // my processor number  
+  const int _myrank;
 
-#define USE_MPI_COMM_DUP
+  int mpi_allgather (int *, int , int *, int) const ;
+  int mpi_allgather (char *, int, char *, int) const ;
+  int mpi_allgather (double *, int, double *, int ) const ;
+public :
+  // constructor taking MPI_Comm 
+  // to avoid MPI types here this is a template constructor 
+  template <class MPICommunicator>  
+  inline MpAccessMPI (MPICommunicator mpicomm ) 
+    : _mpiCommPtr( new Comm<MPICommunicator> ( mpicomm ) ), 
+      _psize( getSize() ), _myrank( getRank() )
+  {
+  }
 
-inline MpAccessMPI :: MpAccessMPI (MPI_Comm i) {
-#ifdef USE_MPI_COMM_DUP
-  MY_INT_TEST MPI_Comm_dup (i, &_mpiComm) ;
-  assert (test == MPI_SUCCESS) ;
-#else 
-  _mpiComm = i;
-#endif
-  return ;
-}
+  // copy constructor 
+  MpAccessMPI (const MpAccessMPI &) ;
+  // destructor 
+  ~MpAccessMPI () ;
+protected:  
+  int getSize () ;
+  int getRank () ;
+public:  
+  inline int psize () const ;
+  inline int myrank () const ;
+  int barrier () const ;
+  int gmax (int) const ;
+  int gmin (int) const ;
+  int gsum (int) const ;
+  long gmax (long) const ;
+  long gmin (long) const ;
+  long gsum (long) const ;
+  double gmax (double) const ;
+  double gmin (double) const ;
+  double gsum (double) const ;
+  void gmax (double*,int,double*) const ;
+  void gmin (double*,int,double*) const ;
+  void gsum (double*,int,double*) const ;
+  pair<double,double> gmax (pair<double,double>) const ;
+  pair<double,double> gmin (pair<double,double>) const ;
+  pair<double,double> gsum (pair<double,double>) const ;
+  vector < int > gcollect (int) const ;
+  vector < double > gcollect (double) const ;
+  vector < vector < int > > gcollect (const vector < int > &) const ;
+  vector < vector < double > > gcollect (const vector < double > &) const ;
+  vector < ObjectStream > gcollect (const ObjectStream &) const ;
+  vector < vector < int > > exchange (const vector < vector < int > > &) const ;
+  vector < vector < double > > exchange (const vector < vector < double > > &) const ;
+  vector < vector < char > > exchange (const vector < vector < char > > &) const ;
+  
+  vector < ObjectStream > exchange (const vector < ObjectStream > &) const ;
 
-inline MpAccessMPI :: MpAccessMPI (const MpAccessMPI & a) {
-#ifdef USE_MPI_COMM_DUP
-  MY_INT_TEST MPI_Comm_dup (a._mpiComm, &_mpiComm) ;
-  assert (test == MPI_SUCCESS) ;
-#else 
-  _mpiComm = a._mpiComm;
-#endif
-  return ;
-}
+  // symectric exchange with same buffer size 
+  void exchange (const vector < ObjectStream > & in,
+                 vector< ObjectStream > & out) const;
+    
+  // return MPI communicator wrapper 
+  const CommIF* communicator() const { return _mpiCommPtr; }
+} ;
 
-inline MpAccessMPI :: ~MpAccessMPI () {
-#ifdef USE_MPI_COMM_DUP
-  MY_INT_TEST MPI_Comm_free (&_mpiComm) ;
-  assert (test == MPI_SUCCESS) ;
-#endif
-  return ;
-}
 
-inline int MpAccessMPI :: psize () const {
-  int i ;
-  MY_INT_TEST MPI_Comm_size (_mpiComm, & i) ;
-  assert (test == MPI_SUCCESS) ;
-  return i ;
+//
+//    #    #    #  #          #    #    #  ######
+//    #    ##   #  #          #    ##   #  #
+//    #    # #  #  #          #    # #  #  #####
+//    #    #  # #  #          #    #  # #  #
+//    #    #   ##  #          #    #   ##  #
+//    #    #    #  ######     #    #    #  ######
+//
+inline int MpAccessMPI :: psize () const 
+{
+  assert( _psize > 0 );
+  //return _psize;
+  return _psize;
 }
 
-inline int MpAccessMPI :: myrank () const {
-  int i ;
-  MY_INT_TEST MPI_Comm_rank (_mpiComm, & i) ;
-  assert (test == MPI_SUCCESS) ;
-  return i ;
+inline int MpAccessMPI :: myrank () const 
+{
+  assert( _myrank != -1 );
+  return _myrank;
 }
-
-inline int MpAccessMPI :: barrier () const {
-  return MPI_SUCCESS == MPI_Barrier (_mpiComm) ? psize () : 0 ;
-}
-
-inline int MpAccessMPI :: mpi_allgather (int * i, int si, int * o, int so) const {
-  return MPI_Allgather (i, si, MPI_INT, o, so, MPI_INT, _mpiComm) ;
-}
-
-inline int MpAccessMPI :: mpi_allgather (char * i, int si, char * o, int so) const {
-  return MPI_Allgather (i, si, MPI_BYTE, o, so, MPI_BYTE, _mpiComm) ;
-}
-
-inline int MpAccessMPI :: mpi_allgather (double * i, int si, double * o, int so) const {
-  return MPI_Allgather (i, si, MPI_DOUBLE, o, so, MPI_DOUBLE, _mpiComm) ;
-}
-
-#undef USE_MPI_COMM_DUP
 #endif
Index: parallel/Makefile.am.include
===================================================================
--- parallel/Makefile.am.include	(revision 1064)
+++ parallel/Makefile.am.include	(revision 1173)
@@ -1,3 +1,3 @@
 paralleldir = parallel
 parallelhdrs = $(paralleldir)/gitter_pll_ldb.h $(paralleldir)/gitter_tetra_top_pll.h $(paralleldir)/mpAccess_MPI.h\
-	$(paralleldir)/gitter_hexa_top_pll.h $(paralleldir)/gitter_pll_mgb.h $(paralleldir)/metis.h $(paralleldir)/parmetis.h $(paralleldir)/party_lib.h $(paralleldir)/gitter_pll_impl.h $(paralleldir)/gitter_pll_sti.h  $(paralleldir)/mpAccess.h
+	$(paralleldir)/gitter_hexa_top_pll.h $(paralleldir)/gitter_pll_mgb.h $(paralleldir)/alumetis.hh $(paralleldir)/aluparmetis.hh $(paralleldir)/aluparty_lib.hh $(paralleldir)/gitter_pll_impl.h $(paralleldir)/gitter_pll_sti.h  $(paralleldir)/mpAccess.h
Index: parallel/gitter_pll_sti.cc
===================================================================
--- parallel/gitter_pll_sti.cc	(revision 1064)
+++ parallel/gitter_pll_sti.cc	(revision 1173)
@@ -1,6 +1,6 @@
 // (c) bernhard schupp 1997 - 1998
 // modifications for dune interface 
-// (c) Robet Kloefkorn 2004 - 2005 
+// (c) Robert Kloefkorn 2004 - 2005 
 #ifndef _GITTER_PLL_STI_CC_
 #define _GITTER_PLL_STI_CC_
 
@@ -35,37 +35,40 @@
     AccessIteratorTT < hface_STI > :: OuterHandle mfo (containerPll (), l) ;
     {
       Insert < AccessIteratorTT < hface_STI > :: InnerHandle, 
-  TreeIterator < hface_STI, has_int_vertex < hface_STI > > > lfi (mfi) ;
+               TreeIterator < hface_STI, has_int_vertex < hface_STI > > > lfi (mfi) ;
       Insert < AccessIteratorTT < hface_STI > :: OuterHandle, 
-  TreeIterator < hface_STI, has_int_vertex < hface_STI > > > lfo (mfo) ;
+               TreeIterator < hface_STI, has_int_vertex < hface_STI > > > lfo (mfo) ;
+
       _iterators_inner.push_back (new Wrapper < Insert < AccessIteratorTT < hface_STI > :: InnerHandle,
-  TreeIterator < hface_STI, has_int_vertex < hface_STI > > >, InternalVertex > (lfi)) ;
+                      TreeIterator < hface_STI, has_int_vertex < hface_STI > > >, InternalVertex > (lfi)) ;
       _iterators_outer.push_back (new Wrapper < Insert < AccessIteratorTT < hface_STI > :: OuterHandle,
-  TreeIterator < hface_STI, has_int_vertex < hface_STI > > >, InternalVertex > (lfo)) ;
+                      TreeIterator < hface_STI, has_int_vertex < hface_STI > > >, InternalVertex > (lfo)) ;
     }
     {
       Insert < AccessIteratorTT < hface_STI > :: InnerHandle, 
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > > lfi (mfi) ;
+               TreeIterator < hface_STI, has_int_edge < hface_STI > > > lfi (mfi) ;
       Insert < AccessIteratorTT < hface_STI > :: OuterHandle, 
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > > lfo (mfo) ;
+               TreeIterator < hface_STI, has_int_edge < hface_STI > > > lfo (mfo) ;
       Wrapper < Insert < AccessIteratorTT < hface_STI > :: InnerHandle, 
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge > dlfi (lfi) ;
+                TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge > dlfi (lfi) ;
       Wrapper < Insert < AccessIteratorTT < hface_STI > :: OuterHandle,
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge > dlfo (lfo) ;
+                TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge > dlfo (lfo) ;
       Insert < Wrapper < Insert < AccessIteratorTT < hface_STI > :: InnerHandle, 
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
-  TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > > vdlfi (dlfi) ;
+               TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
+      TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > > vdlfi (dlfi) ;
       Insert < Wrapper < Insert < AccessIteratorTT < hface_STI > :: OuterHandle,
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
-  TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > > vdlfo (dlfo) ;
+               TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
+               TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > > vdlfo (dlfo) ;
+
       _iterators_inner.push_back (new Wrapper < Insert < Wrapper < 
-  Insert < AccessIteratorTT < hface_STI > :: InnerHandle, 
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
-  TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > >, InternalVertex > (vdlfi)) ;
+                Insert < AccessIteratorTT < hface_STI > :: InnerHandle, 
+                TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
+                TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > >, InternalVertex > (vdlfi)) ;
+
       _iterators_outer.push_back (new Wrapper < 
-  Insert < Wrapper < Insert < AccessIteratorTT < hface_STI > :: OuterHandle,
-  TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
-  TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > >, InternalVertex > (vdlfo)) ;
+        Insert < Wrapper < Insert < AccessIteratorTT < hface_STI > :: OuterHandle,
+        TreeIterator < hface_STI, has_int_edge < hface_STI > > >, InternalEdge >,
+        TreeIterator < hedge_STI, has_int_vertex < hedge_STI > > >, InternalVertex > (vdlfo)) ;
     }
   }
   return pair < IteratorSTI < vertex_STI > *, IteratorSTI < vertex_STI > * > 
@@ -107,7 +110,8 @@
   return ;
 }
 
-void GitterPll :: printsize () {
+void GitterPll :: printsize () 
+{
   const int me = mpAccess ().myrank (), np = mpAccess ().psize (), nl = mpAccess ().nlinks () ;
   
   if (debugOption (10)) Gitter :: printsize () ;
@@ -137,9 +141,22 @@
   }
   n.push_back (LeafIterator < helement_STI > (*this)->size()) ;
   n.push_back (LeafIterator < hbndseg_STI > (*this)->size() - sumCutFaces) ;
+
+  {
+    cout << "\nP[" << me << "] GitterPll :: printSize () : \n\n" ;
+    cout << " - Elements ......... "  << n[3] << "\n" ;
+    cout << " - Boundaries ....... "  << n[4] << "\n" ;
+    cout << " - Faces ............ "  << n[2] << "\n" ;
+    cout << " - Edges ............ "  << n[1] << "\n" ;
+    cout << " - Vertices ......... "  << n[0] << "\n" ;
+    cout << endl ;
+  }
+
   vector < vector < int > > in = mpAccess ().gcollect (n) ;
   assert (static_cast<int> (in.size ()) == np) ;
-  if (me == 0) {
+
+  if (me == 0) 
+  {
     int nv = 0, nd = 0, nf = 0, ne = 0, nb = 0 ;
     for (int i = 0 ; i < np ; i ++ ) {
       nv += (in [i])[0] ;
@@ -148,12 +165,12 @@
       ne += (in [i])[3] ;
       nb += (in [i])[4] ;
     }
-    cout << "\n GitterPll :: printSize () : \n\n" ;
-    cout << " - Elements ......... "  << ne << "\n" ;
+    cout << "\nSummary -- GitterPll :: printSize () : \n\n" ;
+    cout << " - Elements ......... " << ne << "\n" ;
     cout << " - Boundaries ....... " << nb << "\n" ;
     cout << " - Faces ............ " << nf << "\n" ;
-    cout << " - Edges ............ "  << nd << "\n" ;
-    cout << " - Vertices ......... "  << nv << "\n" ;
+    cout << " - Edges ............ " << nd << "\n" ;
+    cout << " - Vertices ......... " << nv << "\n" ;
     cout << endl ;
   }
   return ;
Index: parallel/Makefile.am
===================================================================
--- parallel/Makefile.am	(revision 1064)
+++ parallel/Makefile.am	(revision 1173)
@@ -2,5 +2,4 @@
 AUTOMAKE_OPTIONS = foreign 1.5
 
 EXTRA_DIST = gitter_pll_idn.cc   gitter_pll_ldb.cc  gitter_pll_sti.cc\
-mpAccess_MPI.cc gitter_pll_impl.cc  gitter_pll_mgb.cc  mpAccess.cc\
-metis.c party_lib.c parmetis.c 
+mpAccess_MPI.cc gitter_pll_impl.cc  gitter_pll_mgb.cc  mpAccess.cc
Index: parallel/gitter_pll_sti.h
===================================================================
--- parallel/gitter_pll_sti.h	(revision 1064)
+++ parallel/gitter_pll_sti.h	(revision 1173)
@@ -106,7 +106,10 @@
   // list to iterate 
   list < typename AccessIterator < A > :: Handle > & _l ;
   // current item 
-  typename list < typename AccessIterator < A > :: Handle > :: iterator _curr ;
+  typedef typename list < typename AccessIterator < A > :: Handle > :: iterator listiterator_t ;
+  
+  const listiterator_t _end  ;
+  listiterator_t _curr ;
 
   public :
     listSmartpointer__to__iteratorSTI (list < typename AccessIterator < A > :: Handle > &) ;
@@ -619,12 +622,14 @@
 
 
 template < class A > listSmartpointer__to__iteratorSTI < A > :: 
-listSmartpointer__to__iteratorSTI (list < typename AccessIterator < A > :: Handle > & a) : _l (a) {
+listSmartpointer__to__iteratorSTI (list < typename AccessIterator < A > :: Handle > & a) 
+ : _l (a),  _end( _l.end() ), _curr( _end )
+{
 }
 
 template < class A > listSmartpointer__to__iteratorSTI < A > :: 
 listSmartpointer__to__iteratorSTI (const listSmartpointer__to__iteratorSTI < A > & a) 
-  : _l (a._l) , _curr(a._curr) {}
+  : _l (a._l), _end( _l.end() ), _curr(a._curr) {}
 
 template < class A > listSmartpointer__to__iteratorSTI < A > :: ~listSmartpointer__to__iteratorSTI () {
 }
@@ -639,7 +644,7 @@
 }
 
 template < class A > int listSmartpointer__to__iteratorSTI < A > :: done () const {
-  return _curr == _l.end () ? 1 : 0 ;
+  return (_curr == _end) ? 1 : 0 ;
 }
 
 template < class A > int listSmartpointer__to__iteratorSTI < A > :: size () {
@@ -794,7 +799,8 @@
 {
 }
 
-template < class A > inline LeafIteratorTT < A > :: ~LeafIteratorTT () {
+template < class A > inline LeafIteratorTT < A > :: ~LeafIteratorTT () 
+{
   delete _p.first ;
   delete _p.second ;
 }
Index: parallel/gitter_pll_ldb.cc
===================================================================
--- parallel/gitter_pll_ldb.cc	(revision 1064)
+++ parallel/gitter_pll_ldb.cc	(revision 1173)
@@ -47,28 +47,50 @@
   return ;
 } 
 
-void LoadBalancer :: DataBase :: graphCollect (const MpAccessGlobal & mpa, 
-  insert_iterator < ldb_vertex_map_t > nodes, insert_iterator < ldb_edge_set_t > edges) const {
-  
+void LoadBalancer :: DataBase :: 
+graphCollect (const MpAccessGlobal & mpa, 
+              insert_iterator < ldb_vertex_map_t > nodes, 
+              insert_iterator < ldb_edge_set_t > edges,
+              int* vtxdist, const bool serialPartitioner ) const 
+{
+  // for parallel partitioner return local vertices and edges 
+  // for serial partitioner these have to be communicates to all
+  // processes 
+   
+  if( ! serialPartitioner )
+  {
+    std::cerr << "ParMETIS support not yet implemented! file: " << __FILE__ << " line: " << __LINE__ << std::endl;
+    abort();
+  }
+
   const int np = mpa.psize () ;
   ObjectStream os ;
 
   {
+    // write number of elements  
     int len = _vertexSet.size () ;
     os.writeObject (len) ;
+
+    if( serialPartitioner )
     {
+      // write vertices 
       ldb_vertex_map_t :: const_iterator iEnd = _vertexSet.end () ;
-      for (ldb_vertex_map_t :: const_iterator i = _vertexSet.begin () ; 
-        i != iEnd; os.writeObject ((*i++).first)) ;
+      for (ldb_vertex_map_t :: const_iterator i = _vertexSet.begin () ; i != iEnd; ++i ) 
+      {
+        os.writeObject ((*i).first) ;
+      }
+
+      // write number of edges 
+      len = _edgeSet.size () ;
+      os.writeObject (len) ;
+
+      // write edges 
+      ldb_edge_set_t :: const_iterator eEnd = _edgeSet.end () ;
+      for (ldb_edge_set_t :: const_iterator e = _edgeSet.begin () ; e != eEnd; ++e )
+      {
+        os.writeObject (*e);
+      }
     }
-    
-    len = _edgeSet.size () ;
-    os.writeObject (len) ;
-    {
-      ldb_edge_set_t :: const_iterator iEnd = _edgeSet.end () ;
-      for (ldb_edge_set_t :: const_iterator i = _edgeSet.begin () ; 
-        i != iEnd; os.writeObject (*i++)) ;
-    }
   }
 
   try 
@@ -80,13 +102,16 @@
     os.reset ();
 
     {
-      for (int i = 0 ; i < np ; i ++) 
+      for (int i = 0 ; i < np ; ++i) 
       {
         int len ;
         ObjectStream& osv_i = osv [i];
 
         osv_i.readObject (len) ;
         assert (len >= 0) ;
+
+        // read graph for serial partitioner 
+        if( serialPartitioner ) 
         {
           for (int j = 0 ; j < len ; ++j) 
           {
@@ -94,10 +119,10 @@
             osv_i.readObject (x) ;
             * nodes ++ = pair < const GraphVertex, int > (x,i) ;
           } 
-        }
-        osv_i.readObject (len) ;
-        assert (len >= 0) ;
-        {
+
+          osv_i.readObject (len) ;
+          assert (len >= 0) ;
+
           for (int j = 0 ; j < len ; ++j) 
           {
             GraphEdge x ;
@@ -106,6 +131,12 @@
             * edges ++ = - x ;
           }
         }
+        else 
+        {
+          // see above vtxdist [ 0 ] = 0
+          // sum up number of vertices for processor i 
+          vtxdist[ i + 1 ] = vtxdist[ i ] + len ;
+        }
 
         // free memory of osv[i]
         osv_i.reset();
@@ -181,7 +212,7 @@
     } 
   }
   
-  for (int j = 0; j != nparts ; ++j) 
+  for (int j = 0; j < nparts ; ++j) 
   {
     if (renumber [j] == -1) 
     {
@@ -276,22 +307,36 @@
 
 bool LoadBalancer :: DataBase :: repartition (MpAccessGlobal & mpa, method mth) 
 {
-  const int start = clock (), np = mpa.psize (), me = mpa.myrank () ;
-  bool change (false) ;
-  
   if (debugOption (3)) printLoad () ;
   
+  // if method for load balancing is none, do nothing 
   if (mth == NONE) return false ;
+
+  const int start = clock (), np = mpa.psize (), me = mpa.myrank () ;
+  bool change (false) ;
   
+  // flag to indicate whether we use a serial or a parallel partitioner 
+  const bool serialPartitioner = ( mth != ParMETIS_V3_AdaptiveRepart ); 
+
   // create maps for edges and vertices 
-  ldb_edge_set_t   edges ;
-  ldb_vertex_map_t nodes ; 
+  ldb_edge_set_t    edges ;
+  ldb_vertex_map_t  nodes ; 
 
+  // vector of vertex distribution (only for ParMETIS)
+  int * vtxdist = ( serialPartitioner ) ?  0 : new int [np + 1];
+
+  // collect graph from all processors 
+  // needs a all-to-all (allgather) communication 
   graphCollect (mpa,
                 insert_iterator < ldb_vertex_map_t > (nodes,nodes.begin ()),
-                insert_iterator < ldb_edge_set_t > (edges,edges.begin ())
+                insert_iterator < ldb_edge_set_t > (edges,edges.begin ()), 
+                vtxdist,
+                serialPartitioner 
                ) ;
-  
+
+  // only use ParMETIS_V3_GraphKway for the initial partitioning 
+  const bool usePartKway = ( ! serialPartitioner ) ? vtxdist[0] == vtxdist[ np ] : true ;
+
   // 'ned' ist die Anzahl der Kanten im Graphen, 'nel' die Anzahl der Knoten.
   // Der Container 'nodes' enth"alt alle Knoten des gesamten Grobittergraphen
   // durch Zusammenfhren der einzelnen Container aus den Teilgrobgittern.
@@ -301,22 +346,24 @@
   // im CSR Format daraus erstellt werden m"ussen.
   
   const int ned = edges.size () ;
-  const int nel = nodes.size () ;
+  // for ParMETIS nodes is a local graph that could be empty 
+  const int nel = (serialPartitioner) ? nodes.size () : vtxdist[ np ];
   
-  if (edges.size ()) 
+  // do repartition if edges exist (for serial partitioners) or for
+  // parallel partitioners anyway  
+  if ( ! serialPartitioner || (edges.size() > 0) ) 
   {
-    if (!((*edges.rbegin ()).leftNode () < nel)) 
+    if( serialPartitioner ) 
     {
-      cerr << "**WARNUNG (FEHLER IGNORIERT) Die Indexmenge ist nicht volls\"andig\n" ;
-      cerr << "  \"uberdeckt zur Neupartitionierung. In " << __FILE__ << " " << __LINE__ << endl ;
-      return false ;
+      if (!((*edges.rbegin ()).leftNode () < nel)) 
+      {
+        cerr << "**WARNUNG (FEHLER IGNORIERT) Die Indexmenge ist nicht volls\"andig\n" ;
+        cerr << "  \"uberdeckt zur Neupartitionierung. In " << __FILE__ << " " << __LINE__ << endl ;
+        return false ;
+      }
     }
 
     // allocate edge memory for graph partitioners 
-    //int    * const edge_p      = new int [nel + 1] ;
-    //int    * const edge        = new int [ned] ;
-    //int    * const edge_w      = new int [ned] ;
-
     // get memory at once 
     int    * const edge_mem    = new int [(nel + 1) + ned + ned ];
 
@@ -331,21 +378,25 @@
       int * edge_pPos = edge_p ;
       int count = 0, index = -1 ;
       
-      for (ldb_edge_set_t :: const_iterator i = edges.begin () ; 
-           i != edges.end () ; i ++) 
+      ldb_edge_set_t :: const_iterator iEnd = edges.end();
+      for (ldb_edge_set_t :: const_iterator i = edges.begin () ; i != iEnd ; ++i) 
       {
-        if ((*i).leftNode () != index) 
+        const GraphEdge& e = (*i);
+        if (e.leftNode () != index) 
         {
-          assert ((*i).leftNode () < nel) ;
+          assert ( e.leftNode () < nel) ;
           * edge_pPos ++ = count ;
-          index = (*i).leftNode () ;
+          index = e.leftNode () ;
         }
-        assert ((*i).rightNode () < nel) ;
-        edge [count] = (*i).rightNode () ;
-        edge_w [count ++] = (*i).weight () ;
+        assert ( e.rightNode () < nel) ;
+        edge [ count ] = e.rightNode () ;
+        edge_w [count ++] = e.weight () ;
       }
+
+
       * edge_pPos = count ;
-      assert (edge_p [0] == 0 && edge_p [nel] == ned) ;
+      assert( edge_p [0] == 0 );
+      assert( ( serialPartitioner ) ? edge_p [nel] == ned : true ) ;
 
       // free memory, not needed anymore 
       edges.clear();
@@ -354,47 +405,44 @@
     // get vertex memory 
     float  * const vertex_w    = new float [nel] ;
 
-    //int    * const vertex_wInt = new int [nel] ;
-    //int    * part              = new int [nel] ;
-
     const int sizeNeu = (np > 1) ? nel : 0;
-    int    * vertex_mem = new int [nel + nel + sizeNeu];
-
+    const int memFactor = ( usePartKway ) ? 2 : 3; // need extra memory for adaptive repartitioning
+    int    * vertex_mem = new int [ (memFactor * nel)  + sizeNeu];
     int    * const vertex_wInt = vertex_mem; 
     int    * part              = vertex_mem + nel; 
     
     assert ( vertex_w && vertex_wInt && part) ;
     {
       vector < int > check (nel, 0L) ;
-      for (ldb_vertex_map_t :: const_iterator i = nodes.begin () ; i != nodes.end () ; i ++ ) 
+      ldb_vertex_map_t :: const_iterator iEnd = nodes.end () ;
+      for (ldb_vertex_map_t :: const_iterator i = nodes.begin (); i != iEnd; ++i ) 
       {
-        int j = (*i).first.index () ;
+        const pair< const GraphVertex , int >& item = (*i);
+        const int j = item.first.index () ;
+
         assert (0 <= j && j < nel) ;
-        assert (0 <= (*i).second && (*i).second < np) ;
-        part [j] = (*i).second ;
+        assert (0 <= item.second && item.second < np) ;
+        part [j] = item.second ;
         check [j] = 1 ;
-        vertex_w [j] = vertex_wInt [j] = (*i).first.weight () ;
+        vertex_w [j] = vertex_wInt [j] = item.first.weight () ;
       }
 
+      // store nodes size before clearing   
+      const int nNodes = ( serialPartitioner ) ? nel : nodes.size();
+
       // free memory, not needed anymore
       nodes.clear();
       
-      if (nel != accumulate (check.begin (), check.end (), 0)) 
+      // only for serial partitioners 
+      if (nNodes != accumulate (check.begin (), check.end (), 0)) 
       {
         cerr << "**WARNUNG (IGNORIERT) Keine Neupartitionierung wegen fehlgeschlagenem Konsistenzcheck." ;
         cerr << " In Datei: " << __FILE__ << " Zeile: " << __LINE__ << endl ;
-        /*
-        delete [] part ;
-        delete [] vertex_wInt ;
-        delete [] vertex_w ;
-        delete [] edge_w ;
-        delete [] edge ;
-        delete [] edge_p ;
-        */
 
         delete [] vertex_w ;
         delete [] vertex_mem;
         delete [] edge_mem;
+        delete [] vtxdist ;
 
         return false ;
       }
@@ -404,37 +452,62 @@
     {
       //int * neu = new int [nel] ;
       int * neu = vertex_mem + (2 * nel);
+      assert (neu) ;
 
-      assert (neu) ;
       // copy part to neu, this is needed by some of the partitioning tools  
       copy (part, part + nel, neu) ;
       
-      switch (mth) 
+      if( ! serialPartitioner ) 
       {
-        // Die Methode 'collect' sammelt alle Elemente in einer Partition ein.
+        std::cerr << "ParMETIS support not yet implemented! file: " << __FILE__ << " line: " << __LINE__ << std::endl;
+        abort();
+      }
+      else 
+      {
+        // serial partitioning methods 
+        switch (mth) 
+        {
 
+        // METIS methods 
+        case METIS_PartGraphKway :
+          {
+            int wgtflag = 3, numflag = 0, options = 0, edgecut, n = nel, npart = np ;
+            CALL_METIS_PartGraphKway (&n, edge_p, edge, vertex_wInt, edge_w, 
+                    & wgtflag, & numflag, & npart, & options, & edgecut, neu) ;
+          }
+          break ;
+        case METIS_PartGraphRecursive :
+          {
+            int wgtflag = 3, numflag = 0, options = 0, edgecut, n = nel, npart = np ;
+            CALL_METIS_PartGraphRecursive (&n, edge_p, edge, vertex_wInt, edge_w, 
+                    & wgtflag, & numflag, & npart, & options, & edgecut, neu) ;
+          }
+          break ;
+
+        // the method 'collect' moves all elements to rank 0 
         case COLLECT :
           fill (neu, neu + nel, 0L) ;
           break ;
-          
+
+        // PARTY methods    
         case PARTY_linear :
-          :: global_lin (nel, vertex_w, np, neu) ;
+          CALL_global_lin (nel, vertex_w, np, neu) ;
           break ;
           
         case PARTY_random :
-          :: global_ran (nel, vertex_w, np, neu) ;
+          CALL_global_ran (nel, vertex_w, np, neu) ;
           break ;
           
         case PARTY_scattered :
-          :: global_sca (nel, vertex_w, np, neu) ;
+          CALL_global_sca (nel, vertex_w, np, neu) ;
           break ;
           
         case PARTY_breathfirst :
-          :: global_gbf (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
+          CALL_global_gbf (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
           break ;
           
         case PARTY_cutfirst :
-          :: global_gcf (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
+          CALL_global_gcf (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
           break ;
           
         case PARTY_kernighanLin :
@@ -454,10 +527,10 @@
             // global_linear for the first time 
             if( sum == 0 ) 
             {
-              :: global_lin (nel, vertex_w, np, neu) ;
+              CALL_global_lin (nel, vertex_w, np, neu) ;
             }
             
-            :: local_kl (nel, vertex_w, edge_p, edge, edge_w, np,  neu, 0) ;
+            CALL_local_kl (nel, vertex_w, edge_p, edge, edge_w, np,  neu, 0) ;
           }
           break ;
           
@@ -474,88 +547,66 @@
             // global_linear for the first time 
             if( sum == 0 ) 
             {
-              :: global_lin (nel, vertex_w, np, neu) ;
+              CALL_global_lin (nel, vertex_w, np, neu) ;
             }
             
-            :: local_hs (nel, vertex_w, edge_p, edge, edge_w, np, neu, 0) ;
+            CALL_local_hs (nel, vertex_w, edge_p, edge, edge_w, np, neu, 0) ;
           }
           break ;
 
-        case METIS_PartGraphKway :
-          {
-            int wgtflag = 3, numflag = 0, options = 0, edgecut, n = nel, npart = np ;
-            :: METIS_PartGraphKway (&n, edge_p, edge, vertex_wInt, edge_w, 
-                    & wgtflag, & numflag, & npart, & options, & edgecut, neu) ;
-          }
-          break ;
-        case METIS_PartGraphRecursive :
-          {
-            int wgtflag = 3, numflag = 0, options = 0, edgecut, n = nel, npart = np ;
-            :: METIS_PartGraphRecursive (&n, edge_p, edge, vertex_wInt, edge_w, 
-                    & wgtflag, & numflag, & npart, & options, & edgecut, neu) ;
-          }
-          break ;
-
         default :
           cerr << "**WARNUNG (FEHLER IGNORIERT) Ung\"ultige Methode [" << mth << "] zur\n" ;
           cerr << "  Neupartitionierung angegeben. In " << __FILE__ << " " << __LINE__ << endl ;
             
-          /*
-          delete [] neu ;
-          delete [] part ;
-          delete [] vertex_wInt ;
           delete [] vertex_w ;
-          delete [] edge_w ;
-          delete [] edge ;
-          delete [] edge_p ;
-          */
-
-          delete [] vertex_w ;
           delete [] vertex_mem;
           delete [] edge_mem;
           return false ;
+        }
       }
 
       // collectInsulatedNodes () sucht alle isolierten Knoten im Graphen und klebt
       // diese einfach mit dem Nachbarknoten "uber die Kante mit dem gr"ossten Gewicht
       // zusammen.
 
-      collectInsulatedNodes (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
+      if( serialPartitioner ) 
+      {
+        collectInsulatedNodes (nel, vertex_w, edge_p, edge, edge_w, np, neu) ;
+      }
 
       // optimizeCoverage () versucht, die Lastverschiebung durch Permutation der
       // Gebietszuordnung zu beschleunigen. Wenn die alte Aufteilung von der neuen
       // abweicht, dann wird 'change'auf 'true' gestetzt, damit der Lastverschieber
       // in Aktion tritt.
 
-      optimizeCoverage (np, nel, part, vertex_w, neu, me == 0 ? debugOption (4) : 0) ;
+      if( serialPartitioner ) 
+      {
+        optimizeCoverage (np, nel, part, vertex_w, neu, me == 0 ? debugOption (4) : 0) ;
+      }
 
       // Vergleichen, ob sich die Aufteilung des Gebiets "uberhaupt ver"andert hat.
+      change = ( serialPartitioner ) ? ( ! equal (neu, neu + nel, part) ) : true; 
 
-      change = ! equal (neu, neu + nel, part) ;
-
+      // apply partitioning be reassigning a new processor number 
+      // to the vertices (elements of the macro mesh) of the graph 
       if (change) 
       {
         // Hier die neue Zuordnung auf den eigenen Lastvertex-Container schreiben.
         // Dadurch werden die Grobgitterelemente an das neue Teilgebiet zugewiesen. 
 
-        for (ldb_vertex_map_t :: iterator i = _vertexSet.begin () ; i != _vertexSet.end () ; i ++)
-          _connect.insert ((*i).second = neu [(*i).first.index ()]) ;
+        ldb_vertex_map_t :: iterator iEnd =  _vertexSet.end () ;
+        for (ldb_vertex_map_t :: iterator i = _vertexSet.begin () ; i != iEnd ; ++i)
+        {
+          // insert and also set partition number new 
+          _connect.insert( (*i).second = neu [ (*i).first.index () ]) ;
+        }
       }
-      
-      //delete [] neu ;
     }
 
     delete [] vertex_w ;
     delete [] vertex_mem;
     delete [] edge_mem;
-    /*
-    delete [] part ;
-    delete [] vertex_wInt ;
-    delete [] vertex_w ;
-    delete [] edge_w ;
-    delete [] edge ;
-    delete [] edge_p ;
-    */
+    delete [] vtxdist ;
   }
 
 
@@ -570,8 +621,6 @@
 
 int LoadBalancer :: DataBase :: getDestination (int i) const 
 {
-  //const double p [3] = {0.0,0.0,0.0} ;
-  //GraphVertex e (i,0,p) ;
   // use constructor to initialize default values 
   GraphVertex e (i) ;
   assert (_vertexSet.find (e) != _vertexSet.end ()) ;
@@ -582,10 +631,11 @@
   return _connect ;
 }
 
-const char * LoadBalancer :: DataBase :: methodToString (method m) {
+const char * LoadBalancer :: DataBase :: methodToString (method m) 
+{
   switch (m) {
     case NONE :
-      return "keine dynamische Lastverteilung" ;
+      return "no dynamic load balancing" ;
     case COLLECT :
       return "COLLECT" ;
     case PARTY_helpfulSet :
@@ -606,8 +656,10 @@
       return "METIS_PartGraphKway" ;
     case METIS_PartGraphRecursive :
       return "METIS_PartGraphRecursive" ;
+    case ParMETIS_V3_AdaptiveRepart :
+      return "ParMETIS_V3_PartKway / ParMETIS_V3_AdaptiveRepart" ;
     default :
-      return "unbekannte Methode" ;
+      return "unknown method" ;
   }
   return "" ;
 }
Index: parallel/gitter_pll_impl.cc
===================================================================
--- parallel/gitter_pll_impl.cc	(revision 1064)
+++ parallel/gitter_pll_impl.cc	(revision 1173)
@@ -1650,8 +1650,10 @@
   return ;
 }
 
-GitterBasisPll :: MacroGitterBasisPll :: MacroGitterBasisPll (Gitter * mygrid , istream & in) : GitterPll :: MacroGitterPll () , GitterBasis:: MacroGitterBasis (mygrid) {
-  macrogridBuilder (in) ;
+GitterBasisPll :: MacroGitterBasisPll :: MacroGitterBasisPll (Gitter * mygrid , istream & in) : GitterPll :: MacroGitterPll () , GitterBasis:: MacroGitterBasis (mygrid) 
+{
+  assert( mygrid );
+  macrogridBuilder (in, mygrid->vertexProjection() ) ;
   return ;
 }
 
@@ -1776,17 +1778,17 @@
 }
 
 Gitter :: Geometric :: hbndseg4_GEO * GitterBasisPll :: MacroGitterBasisPll :: 
-insert_hbnd4 (hface4_GEO * f, int t, Gitter :: hbndseg_STI :: bnd_t b) 
+insert_hbnd4 (hface4_GEO * f, int t, ProjectVertex* ppv, Gitter :: hbndseg_STI :: bnd_t b) 
 {
   if (b == Gitter :: hbndseg_STI :: closure) 
   {
     // internal face always get dummy index manager      
     typedef GitterBasis :: Objects :: Hbnd4Default Hbnd4DefaultType;
     return new Hbnd4PllInternal < Hbnd4DefaultType , BndsegPllBaseXClosure < Hbnd4DefaultType > , 
-          BndsegPllBaseXMacroClosure < Hbnd4DefaultType > > :: macro_t (f,t, NULL, b, indexManager(IM_Internal) , this->_myGrid , *this ) ;
+          BndsegPllBaseXMacroClosure < Hbnd4DefaultType > > :: macro_t (f,t, NULL, b, indexManager(IM_Internal), *this ) ;
   } else {
     return new Hbnd4PllExternal < GitterBasis :: Objects :: Hbnd4Default, 
-        BndsegPllBaseXMacro < hbndseg4_GEO > > (f,t, NULL, b, indexManager(IM_Bnd) , 0 ) ;
+        BndsegPllBaseXMacro < hbndseg4_GEO > > (f,t, ppv, b, indexManager(IM_Bnd) ) ;
   }
 }
 
@@ -1795,12 +1797,12 @@
 {
   Gitter :: hbndseg_STI :: bnd_t b = Gitter :: hbndseg_STI :: ghost_closure;
   return new Hbnd4PllExternal < GitterBasis :: Objects :: Hbnd4Default, 
-    BndsegPllBaseXMacro < hbndseg4_GEO > > (f,t, NULL, b, indexManager(IM_Internal) , 0 ) ;
+    BndsegPllBaseXMacro < hbndseg4_GEO > > (f,t, NULL, b, indexManager(IM_Internal)) ;
 }
 
 
 Gitter :: Geometric :: hbndseg4_GEO * GitterBasisPll :: MacroGitterBasisPll :: 
-insert_hbnd4 (hface4_GEO * f, int t, Gitter :: hbndseg_STI :: bnd_t b, 
+insert_hbnd4 (hface4_GEO * f, int t, ProjectVertex* ppv, Gitter :: hbndseg_STI :: bnd_t b, 
               MacroGhostInfoHexa* ghInfo) 
 { 
   typedef GitterBasis :: Objects :: Hbnd4Default Hbnd4DefaultType;
@@ -1810,18 +1812,19 @@
     assert( ghInfo );
     return new Hbnd4PllInternal < Hbnd4DefaultType , BndsegPllBaseXClosure < Hbnd4DefaultType > , 
           BndsegPllBaseXMacroClosure < Hbnd4DefaultType > > :: 
-          macro_t (f,t, NULL, b, indexManager(IM_Internal) , this->_myGrid , *this, ghInfo ) ;
+          macro_t (f,t, NULL, b, indexManager(IM_Internal), *this, ghInfo ) ;
   } 
   else 
   {
     return new Hbnd4PllExternal < Hbnd4DefaultType , 
-        BndsegPllBaseXMacro < hbndseg4_GEO > > (f,t, NULL, b, indexManager(IM_Bnd) , 0 ) ;
+        BndsegPllBaseXMacro < hbndseg4_GEO > > (f,t, ppv, b, indexManager(IM_Bnd) ) ;
   }
 }
 
 // version with point 
 Gitter :: Geometric :: hbndseg3_GEO * GitterBasisPll :: MacroGitterBasisPll :: 
-insert_hbnd3 (hface3_GEO * f, int t, Gitter :: hbndseg_STI :: bnd_t b, 
+insert_hbnd3 (hface3_GEO * f, int t, ProjectVertex* ppv,
+              Gitter :: hbndseg_STI :: bnd_t b, 
               MacroGhostInfoTetra * ghInfo) 
 {
   typedef GitterBasis :: Objects :: Hbnd3Default Hbnd3DefaultType;
@@ -1831,30 +1834,31 @@
     // this HbnPll has a ghost element so is dosent get and index ==> dummyindex == 5 (see gitter_sti.h)
     return new Hbnd3PllInternal < Hbnd3DefaultType , BndsegPllBaseXClosure < Hbnd3DefaultType > , 
           BndsegPllBaseXMacroClosure < Hbnd3DefaultType > > :: 
-              macro_t (f,t,NULL, b, indexManager(IM_Internal) , this->_myGrid , *this, ghInfo ) ;
+              macro_t (f,t,NULL, b, indexManager(IM_Internal), *this, ghInfo ) ;
   } 
   else 
   {
     return new Hbnd3PllExternal < Hbnd3DefaultType , 
-        BndsegPllBaseXMacro < hbndseg3_GEO > > (f,t,NULL, b, indexManager(IM_Bnd) , 0 ) ;
+        BndsegPllBaseXMacro < hbndseg3_GEO > > (f,t, ppv, b, indexManager(IM_Bnd) ) ;
   }
 }
 
 // version without point 
 Gitter :: Geometric :: hbndseg3_GEO * GitterBasisPll :: MacroGitterBasisPll :: 
-insert_hbnd3 (hface3_GEO * f, int t, Gitter :: hbndseg_STI :: bnd_t b ) 
+insert_hbnd3 (hface3_GEO * f, int t, ProjectVertex* ppv, 
+              Gitter :: hbndseg_STI :: bnd_t b ) 
 {
   typedef GitterBasis :: Objects :: Hbnd3Default Hbnd3DefaultType;
   if (b == Gitter :: hbndseg_STI :: closure) 
   {
     // here we have a ghost of the ghost, therefor we need the element index manager 
     return new Hbnd3PllInternal < Hbnd3DefaultType , BndsegPllBaseXClosure < Hbnd3DefaultType > , 
-          BndsegPllBaseXMacroClosure < Hbnd3DefaultType > > :: macro_t (f,t,NULL, b, indexManager(IM_Internal) , this->_myGrid , *this ) ;
+          BndsegPllBaseXMacroClosure < Hbnd3DefaultType > > :: macro_t (f,t, ppv, b, indexManager(IM_Internal), *this ) ;
   } 
   else 
   {
     return new Hbnd3PllExternal < Hbnd3DefaultType , 
-           BndsegPllBaseXMacro < hbndseg3_GEO > > (f,t,NULL, b, indexManager(IM_Bnd), 0 ) ;
+           BndsegPllBaseXMacro < hbndseg3_GEO > > (f,t, ppv, b, indexManager(IM_Bnd) ) ;
   }
 }
 
@@ -1865,7 +1869,7 @@
   typedef GitterBasis :: Objects :: Hbnd3Default Hbnd3DefaultType;
 
   return new Hbnd3PllExternal < Hbnd3DefaultType , 
-         BndsegPllBaseXMacro < hbndseg3_GEO > > (f,t,NULL, b, indexManager(IM_Bnd), 0 ) ;
+         BndsegPllBaseXMacro < hbndseg3_GEO > > (f,t, NULL, b, indexManager(IM_Bnd) );
 }
 
 IteratorSTI < Gitter :: vertex_STI > * GitterBasisPll :: MacroGitterBasisPll :: iterator (const vertex_STI * a) const {
@@ -1908,43 +1912,66 @@
   return GitterBasis :: MacroGitterBasis :: iterator (a) ;
 }
 
-GitterBasisPll :: GitterBasisPll (MpAccessLocal & mpa) : _mpaccess (mpa), _macrogitter (0) {
+GitterBasisPll :: GitterBasisPll (MpAccessLocal & mpa) 
+  : _mpaccess (mpa), _macrogitter (0) , _ppv( 0 ) {
   _macrogitter = new MacroGitterBasisPll (this) ;
   assert (_macrogitter) ;
   notifyMacroGridChanges () ;
   return ;
 }
 
-GitterBasisPll :: GitterBasisPll (const char * f, MpAccessLocal & mpa) 
-  : GitterPll(mpa.myrank() == 0) , _mpaccess (mpa), _macrogitter (0) 
+GitterBasisPll :: GitterBasisPll (const string filename, 
+                                  MpAccessLocal & mpa, ProjectVertex* ppv ) 
+  : GitterPll(mpa.myrank() == 0) , _mpaccess (mpa), _macrogitter (0) , _ppv( ppv ) 
 {
-  assert (debugOption (20) ? (cout << "GitterBasisPll :: GitterBasisPll (const char * = \"" << f << "\" ...)" << endl, 1) : 1) ;
+  assert (debugOption (20) ? (cout << "GitterBasisPll :: GitterBasisPll (const char * = \"" << filename << "\" ...)" << endl, 1) : 1) ;
 
+  const int myrank = mpa.myrank();
+  stringstream rank;
+  rank << "." << myrank;
+
   // if still no macrogitter, try old method 
   if(!_macrogitter) 
   {
-    char * extendedName = new char [strlen(f) + 200] ;
-    sprintf (extendedName, "%s.%u", f, mpa.myrank ()) ;
-    ifstream in (extendedName) ;
-    if (in) {
-      _macrogitter = new MacroGitterBasisPll (this,in) ;
+    string extendedName ( filename );
+    extendedName += rank.str();
+
+    ifstream in (extendedName.c_str()) ;
+    if (in) 
+    {
+      _macrogitter = new MacroGitterBasisPll (this, in) ;
     } 
     else 
     {
       assert (debugOption (5) ? 
         ( cerr << "  GitterBasisPll :: GitterBasisPll () file: " << extendedName 
-           << " cannot be read. Try " << f << " instead. In " << __FILE__ << " line " << __LINE__ << endl, 1) : 1);
+           << " cannot be read. Try " << filename << " instead. In " << __FILE__ << " line " << __LINE__ << endl, 1) : 1);
     }
-    delete [] extendedName ;
   }
 
-  // read normal macro gitter if myrank is 0 
-  //if( (mpa.myrank () == 0) && !_macrogitter )
-  if( !_macrogitter )
+  // only check this for higher ranks 
+  // we assume that filename already contains rank info
+  // if not empty grid is created 
+  bool validFilename = true ;
+  if( ! _macrogitter && myrank > 0 )
   {
-    ifstream in ( f ) ;
-    if (in) _macrogitter = new MacroGitterBasisPll (this,in) ;
+    // search rank info in filename 
+    const int result = filename.rfind( rank.str() );
+    // if not found then filename is not valid 
+    // and empty grid should be created 
+    if( result == -1 )
+    {
+      validFilename = false ;
+    }
   }
+
+  // read normal macro gitter if not created yet and 
+  // filename is valid for this rank  
+  if( ! _macrogitter && validFilename ) 
+  {
+    ifstream in ( filename.c_str() ) ;
+    if (in) _macrogitter = new MacroGitterBasisPll (this, in) ;
+  }
   
   // create empty macro gitter 
   if(!_macrogitter) _macrogitter = new MacroGitterBasisPll (this) ;
Index: parallel/gitter_pll_ldb.h
===================================================================
--- parallel/gitter_pll_ldb.h	(revision 1064)
+++ parallel/gitter_pll_ldb.h	(revision 1173)
@@ -51,7 +51,8 @@
     class DataBase {
       public :
         typedef map < GraphVertex, int, less < GraphVertex > >  ldb_vertex_map_t ;
-        typedef set < GraphEdge, less < GraphEdge > >     ldb_edge_set_t ;
+        typedef set < GraphEdge, less < GraphEdge > >           ldb_edge_set_t ;
+        typedef vector< int >                                   ldb_vector_t ;
       public :
         class AccVertexLoad {
           public :
@@ -69,13 +70,15 @@
         set < int, less < int > > _connect ;
         ldb_edge_set_t   _edgeSet ;
         ldb_vertex_map_t _vertexSet ;
-      private :
-        void graphCollect (const MpAccessGlobal &,insert_iterator < ldb_vertex_map_t >,
-                           insert_iterator < ldb_edge_set_t >) const ;
       public :
         enum method { 
+          // no load balancing 
           NONE = 0,
+
+          // collect all to rank 0 
           COLLECT = 1,
+
+          // PARTY methods 
           PARTY_helpfulSet = 3, 
           PARTY_kernighanLin = 4,
           PARTY_random = 5, 
@@ -84,9 +87,18 @@
           PARTY_breathfirst = 8,
           PARTY_cutfirst = 9, 
 
+          // METIS method for graph partitioning 
           METIS_PartGraphKway = 11,
-          METIS_PartGraphRecursive = 12
+          METIS_PartGraphRecursive = 12,
+
+          // ParMETIS method for adaptive repartition 
+          ParMETIS_V3_AdaptiveRepart = 13   
         } ;
+      private :
+        void graphCollect (const MpAccessGlobal &,insert_iterator < ldb_vertex_map_t >,
+                           insert_iterator < ldb_edge_set_t >,
+                           int * , const bool ) const ;
+      public :
         static const char * methodToString (method) ;
         inline DataBase () ;
         inline DataBase (const DataBase &) ;
Index: parallel/gitter_pll_impl.h
===================================================================
--- parallel/gitter_pll_impl.h	(revision 1064)
+++ parallel/gitter_pll_impl.h	(revision 1173)
@@ -807,16 +807,16 @@
         virtual VertexGeo     * insert_ghostvx (double,double,double,int) ;
        
         // insert hbnd_int without ghost hexa 
-        virtual hbndseg4_GEO  * insert_hbnd4  (hface4_GEO *, int,Gitter :: hbndseg_STI :: bnd_t) ;
+        virtual hbndseg4_GEO  * insert_hbnd4  (hface4_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t) ;
         // insert hbnd_int without ghost hexa 
         virtual hbndseg4_GEO  * insert_hbnd4_ghost (hface4_GEO *, int) ;
         // insert hbnd_int with ghost hexa 
-        virtual hbndseg4_GEO  * insert_hbnd4  (hface4_GEO *, int,Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoHexa* );
+        virtual hbndseg4_GEO  * insert_hbnd4  (hface4_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoHexa* );
         
         // normal insert hbnd3 version
-  virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int,Gitter :: hbndseg_STI :: bnd_t) ;
+  virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t) ;
         // version that get point and create ghost macro 
-  virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int,Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoTetra* ) ;
+  virtual hbndseg3_GEO  * insert_hbnd3 (hface3_GEO *, int, ProjectVertex*, Gitter :: hbndseg_STI :: bnd_t, MacroGhostInfoTetra* ) ;
         // version that created internal boundary on ghost elements 
   virtual hbndseg3_GEO  * insert_hbnd3_ghost  (hface3_GEO *, int) ;
         virtual hedge1_GEO    * insert_hedge1 (VertexGeo *, VertexGeo *) ;
@@ -847,7 +847,8 @@
     } ;
   protected :
     MpAccessLocal & _mpaccess ;
-    MacroGitterPll * _macrogitter ;
+    MacroGitterPll* _macrogitter ;
+    ProjectVertex*  _ppv;
   public :
     virtual inline Makrogitter & container () ;
     virtual inline const Makrogitter & container () const ;
@@ -860,9 +861,11 @@
     virtual inline MacroGitterPll & containerPll () ;
     virtual inline const MacroGitterPll & containerPll () const ;
 
-    GitterBasisPll (const char *, MpAccessLocal &) ;
+    GitterBasisPll (const string, MpAccessLocal &, ProjectVertex* ) ;
 
     virtual ~GitterBasisPll () ;
+
+    virtual ProjectVertex* vertexProjection() const { return _ppv; }
     
     //virtual void printMemUsage();
 } ;
@@ -1414,7 +1417,8 @@
   return ;
 }
 
-template < class A > void BndsegPllBaseXClosure < A > :: readDynamicState (ObjectStream & os, GatherScatterType & gs ) {
+template < class A > void BndsegPllBaseXClosure < A > :: readDynamicState (ObjectStream & os, GatherScatterType & gs ) 
+{
   gs.recvData( os , myhbnd () );
   return ;
 }
Index: parallel/gitter_tetra_top_pll.h
===================================================================
--- parallel/gitter_tetra_top_pll.h	(revision 1064)
+++ parallel/gitter_tetra_top_pll.h	(revision 1173)
@@ -21,7 +21,7 @@
     typedef typename A :: myhface3_t myhface3_t ;
     typedef typename A :: bnd_t     bnd_t ;
   public :
-    inline Hbnd3PllExternal (myhface3_t *, int, ProjectVertex *, const bnd_t bt, IndexManagerType & , Gitter * ) ;
+    inline Hbnd3PllExternal (myhface3_t *, int, ProjectVertex *, const bnd_t bt, IndexManagerType & ) ;
     inline ~Hbnd3PllExternal () ;
     ElementPllXIF_t & accessPllX () throw (Parallel :: AccessPllException) ;
     const ElementPllXIF_t & accessPllX () const throw (Parallel :: AccessPllException) ;
@@ -52,7 +52,7 @@
         typedef typename A :: balrule_t balrule_t ;
         typedef typename A :: bnd_t     bnd_t ;
         
-        inline HbndPll (myhface3_t *, int, ProjectVertex * , Gitter * );
+        inline HbndPll (myhface3_t *, int, ProjectVertex * );
         ~HbndPll () {}
         virtual bool bndNotifyBalance (balrule_t,int) ;
         virtual bool lockedAgainstCoarsening () const ;
@@ -106,10 +106,10 @@
         virtual bool lockedAgainstCoarsening () const ;
       public :
         HbndPllMacro (myhface3_t *,int, ProjectVertex *, const bnd_t bt , 
-                      IndexManagerType & im, Gitter * , 
+                      IndexManagerType & im,
                       BuilderIF& , MacroGhostInfoTetra* ) ;
         HbndPllMacro (myhface3_t *,int, ProjectVertex *, const bnd_t bt , 
-                      IndexManagerType & im, Gitter * , BuilderIF& ) ;
+                      IndexManagerType & im, BuilderIF& ) ;
        ~HbndPllMacro () ;
         ElementPllXIF_t & accessPllX () throw (Parallel :: AccessPllException) ;
         const ElementPllXIF_t & accessPllX () const throw (Parallel :: AccessPllException) ;
@@ -136,8 +136,8 @@
 //    #    #    #  ######     #    #    #  ######
 //
 template < class A, class MX > inline Hbnd3PllExternal < A, MX > :: 
-Hbnd3PllExternal (myhface3_t * f, int t, ProjectVertex *ppv, const bnd_t bt , IndexManagerType & im, Gitter * grd ) 
-    : Hbnd3Top < A > (0,f,t,ppv,this,bt,im,grd), _mxt (new MX (*this)) {
+Hbnd3PllExternal (myhface3_t * f, int t, ProjectVertex *ppv, const bnd_t bt , IndexManagerType & im ) 
+    : Hbnd3Top < A > (0,f,t,ppv,bt,im), _mxt (new MX (*this)) {
   this->restoreFollowFace () ;
   return ;
 }
@@ -165,8 +165,8 @@
 }
 
 template < class A, class X, class MX > inline Hbnd3PllInternal < A, X, MX > :: HbndPll :: 
-HbndPll (myhface3_t * f, int t, ProjectVertex *ppv , Gitter * grd )
-  : A (f,t,ppv,grd), _ext (*this), _ghostPair( (helement_STI *) 0, -1) {
+HbndPll (myhface3_t * f, int t, ProjectVertex *ppv )
+  : A (f,t,ppv), _ext (*this), _ghostPair( (helement_STI *) 0, -1) {
   return ;
 }
 
@@ -336,10 +336,10 @@
 template < class A, class X, class MX > 
 Hbnd3PllInternal < A, X, MX > :: HbndPllMacro :: 
 HbndPllMacro (myhface3_t * f, int t, ProjectVertex *ppv , 
-    const bnd_t bt, IndexManagerType & im , Gitter * grd, 
+    const bnd_t bt, IndexManagerType & im, 
     BuilderIF& mgb ,
     MacroGhostInfoTetra* ghInfo) 
- : Hbnd3Top < micro_t > (0,f,t,ppv,0,bt,im,grd) 
+ : Hbnd3Top < micro_t > (0,f,t,ppv,bt,im) 
  , _mxt(0)
  , _mgb(mgb)
  , _gm( new MacroGhostTetra( _mgb , ghInfo, f ) ) 
@@ -355,9 +355,9 @@
 template < class A, class X, class MX > 
 Hbnd3PllInternal < A, X, MX > :: HbndPllMacro :: 
 HbndPllMacro (myhface3_t * f, int t, ProjectVertex *ppv , 
-    const bnd_t bt, IndexManagerType & im , Gitter * grd, 
+    const bnd_t bt, IndexManagerType & im ,  
     BuilderIF& mgb ) 
- : Hbnd3Top < micro_t > (0,f,t,ppv,0,bt,im,grd) 
+ : Hbnd3Top < micro_t > (0,f,t,ppv,bt,im) 
  , _mxt ( new MX (*this) )
  , _mgb(mgb)
  , _gm( 0 ) 
